//Generated by TurboLink CodeGenerator, do not edit!
#include "EcsStreamContext.h"
#include "SEcsstream/EcsStreamClient.h"
#include "EcsStreamService_Private.h"
#include "EcsStreamMarshaling.h"
#include "TurboLinkGrpcManager.h"

GrpcContext_ECSStreamService_SubscribeToStreamLatest::GrpcContext_ECSStreamService_SubscribeToStreamLatest(FGrpcContextHandle _Handle, UGrpcService* _Service, UGrpcClient* _Client)
	: Super(_Handle, _Service, _Client)
{
}

void GrpcContext_ECSStreamService_SubscribeToStreamLatest::Call(const FGrpcEcsstreamECSStreamBlockBundleRequest& Request)
{
	check(GetState() == EGrpcContextState::Ready);
	UpdateState(EGrpcContextState::Initialing);

	::ecsstream::ECSStreamBlockBundleRequest rpcRequest;
	TURBOLINK_TO_GRPC(&Request, &rpcRequest);

	UECSStreamService* service = (UECSStreamService*)Service;
	RpcReaderWriter = service->d->Stub->AsyncSubscribeToStreamLatest(RpcContext.get(), rpcRequest, service->TurboLinkManager->d->CompletionQueue.get(), InitialTag);
}

void GrpcContext_ECSStreamService_SubscribeToStreamLatest::OnRpcEvent(bool Ok, const void* EventTag)
{
	Super::OnRpcEventInternal(Ok, EventTag, [this](const FGrpcResult& _Result, ::ecsstream::ECSStreamBlockBundleReply* _RpcResponse) {
		UECSStreamServiceClient* client = (UECSStreamServiceClient*)(this->Client);
		if (!(client->OnSubscribeToStreamLatestResponse.IsBound())) return;

		FGrpcEcsstreamECSStreamBlockBundleReply response;
		if (_RpcResponse) {
			GRPC_TO_TURBOLINK(_RpcResponse, &response);
		}
		client->OnSubscribeToStreamLatestResponse.Broadcast(Handle, _Result, response);
	});
}
