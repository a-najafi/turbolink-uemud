#if defined(_MSC_VER)
  #pragma warning (disable:4946) // reinterpret_cast used between related classes: 'class1' and 'class2'
  #pragma warning (disable:4800) // 'type' : forcing value to bool 'true' or 'false' (performance warning)
#endif
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ecs_stream.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ecs_5fstream_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ecs_5fstream_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ecs_5fstream_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ecs_5fstream_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ecs_5fstream_2eproto;
namespace ecsstream {
class ECSEvent;
struct ECSEventDefaultTypeInternal;
extern ECSEventDefaultTypeInternal _ECSEvent_default_instance_;
class ECSStreamBlockBundleReply;
struct ECSStreamBlockBundleReplyDefaultTypeInternal;
extern ECSStreamBlockBundleReplyDefaultTypeInternal _ECSStreamBlockBundleReply_default_instance_;
class ECSStreamBlockBundleRequest;
struct ECSStreamBlockBundleRequestDefaultTypeInternal;
extern ECSStreamBlockBundleRequestDefaultTypeInternal _ECSStreamBlockBundleRequest_default_instance_;
class TxMetadata;
struct TxMetadataDefaultTypeInternal;
extern TxMetadataDefaultTypeInternal _TxMetadata_default_instance_;
}  // namespace ecsstream
PROTOBUF_NAMESPACE_OPEN
template<> ::ecsstream::ECSEvent* Arena::CreateMaybeMessage<::ecsstream::ECSEvent>(Arena*);
template<> ::ecsstream::ECSStreamBlockBundleReply* Arena::CreateMaybeMessage<::ecsstream::ECSStreamBlockBundleReply>(Arena*);
template<> ::ecsstream::ECSStreamBlockBundleRequest* Arena::CreateMaybeMessage<::ecsstream::ECSStreamBlockBundleRequest>(Arena*);
template<> ::ecsstream::TxMetadata* Arena::CreateMaybeMessage<::ecsstream::TxMetadata>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ecsstream {

// ===================================================================

class TxMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecsstream.TxMetadata) */ {
 public:
  inline TxMetadata() : TxMetadata(nullptr) {}
  ~TxMetadata() override;
  explicit constexpr TxMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxMetadata(const TxMetadata& from);
  TxMetadata(TxMetadata&& from) noexcept
    : TxMetadata() {
    *this = ::std::move(from);
  }

  inline TxMetadata& operator=(const TxMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxMetadata& operator=(TxMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxMetadata* internal_default_instance() {
    return reinterpret_cast<const TxMetadata*>(
               &_TxMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TxMetadata& a, TxMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(TxMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TxMetadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecsstream.TxMetadata";
  }
  protected:
  explicit TxMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToFieldNumber = 2,
    kDataFieldNumber = 3,
    kValueFieldNumber = 4,
  };
  // string to = 2;
  void clear_to();
  const std::string& to() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to();
  PROTOBUF_NODISCARD std::string* release_to();
  void set_allocated_to(std::string* to);
  private:
  const std::string& _internal_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(const std::string& value);
  std::string* _internal_mutable_to();
  public:

  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint64 value = 4;
  void clear_value();
  uint64_t value() const;
  void set_value(uint64_t value);
  private:
  uint64_t _internal_value() const;
  void _internal_set_value(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ecsstream.TxMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  uint64_t value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecs_5fstream_2eproto;
};
// -------------------------------------------------------------------

class ECSEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecsstream.ECSEvent) */ {
 public:
  inline ECSEvent() : ECSEvent(nullptr) {}
  ~ECSEvent() override;
  explicit constexpr ECSEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ECSEvent(const ECSEvent& from);
  ECSEvent(ECSEvent&& from) noexcept
    : ECSEvent() {
    *this = ::std::move(from);
  }

  inline ECSEvent& operator=(const ECSEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ECSEvent& operator=(ECSEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ECSEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ECSEvent* internal_default_instance() {
    return reinterpret_cast<const ECSEvent*>(
               &_ECSEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ECSEvent& a, ECSEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ECSEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ECSEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ECSEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ECSEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ECSEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ECSEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ECSEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecsstream.ECSEvent";
  }
  protected:
  explicit ECSEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventTypeFieldNumber = 1,
    kComponentIdFieldNumber = 2,
    kEntityIdFieldNumber = 3,
    kValueFieldNumber = 4,
    kTxHashFieldNumber = 5,
    kTxMetadataFieldNumber = 6,
  };
  // string eventType = 1;
  void clear_eventtype();
  const std::string& eventtype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_eventtype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_eventtype();
  PROTOBUF_NODISCARD std::string* release_eventtype();
  void set_allocated_eventtype(std::string* eventtype);
  private:
  const std::string& _internal_eventtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_eventtype(const std::string& value);
  std::string* _internal_mutable_eventtype();
  public:

  // string componentId = 2;
  void clear_componentid();
  const std::string& componentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_componentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_componentid();
  PROTOBUF_NODISCARD std::string* release_componentid();
  void set_allocated_componentid(std::string* componentid);
  private:
  const std::string& _internal_componentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_componentid(const std::string& value);
  std::string* _internal_mutable_componentid();
  public:

  // string entityId = 3;
  void clear_entityid();
  const std::string& entityid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entityid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entityid();
  PROTOBUF_NODISCARD std::string* release_entityid();
  void set_allocated_entityid(std::string* entityid);
  private:
  const std::string& _internal_entityid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entityid(const std::string& value);
  std::string* _internal_mutable_entityid();
  public:

  // bytes value = 4;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // string txHash = 5;
  void clear_txhash();
  const std::string& txhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_txhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_txhash();
  PROTOBUF_NODISCARD std::string* release_txhash();
  void set_allocated_txhash(std::string* txhash);
  private:
  const std::string& _internal_txhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_txhash(const std::string& value);
  std::string* _internal_mutable_txhash();
  public:

  // .ecsstream.TxMetadata txMetadata = 6;
  bool has_txmetadata() const;
  private:
  bool _internal_has_txmetadata() const;
  public:
  void clear_txmetadata();
  const ::ecsstream::TxMetadata& txmetadata() const;
  PROTOBUF_NODISCARD ::ecsstream::TxMetadata* release_txmetadata();
  ::ecsstream::TxMetadata* mutable_txmetadata();
  void set_allocated_txmetadata(::ecsstream::TxMetadata* txmetadata);
  private:
  const ::ecsstream::TxMetadata& _internal_txmetadata() const;
  ::ecsstream::TxMetadata* _internal_mutable_txmetadata();
  public:
  void unsafe_arena_set_allocated_txmetadata(
      ::ecsstream::TxMetadata* txmetadata);
  ::ecsstream::TxMetadata* unsafe_arena_release_txmetadata();

  // @@protoc_insertion_point(class_scope:ecsstream.ECSEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr eventtype_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr componentid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entityid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txhash_;
  ::ecsstream::TxMetadata* txmetadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecs_5fstream_2eproto;
};
// -------------------------------------------------------------------

class ECSStreamBlockBundleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecsstream.ECSStreamBlockBundleRequest) */ {
 public:
  inline ECSStreamBlockBundleRequest() : ECSStreamBlockBundleRequest(nullptr) {}
  ~ECSStreamBlockBundleRequest() override;
  explicit constexpr ECSStreamBlockBundleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ECSStreamBlockBundleRequest(const ECSStreamBlockBundleRequest& from);
  ECSStreamBlockBundleRequest(ECSStreamBlockBundleRequest&& from) noexcept
    : ECSStreamBlockBundleRequest() {
    *this = ::std::move(from);
  }

  inline ECSStreamBlockBundleRequest& operator=(const ECSStreamBlockBundleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ECSStreamBlockBundleRequest& operator=(ECSStreamBlockBundleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ECSStreamBlockBundleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ECSStreamBlockBundleRequest* internal_default_instance() {
    return reinterpret_cast<const ECSStreamBlockBundleRequest*>(
               &_ECSStreamBlockBundleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ECSStreamBlockBundleRequest& a, ECSStreamBlockBundleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ECSStreamBlockBundleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ECSStreamBlockBundleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ECSStreamBlockBundleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ECSStreamBlockBundleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ECSStreamBlockBundleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ECSStreamBlockBundleRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ECSStreamBlockBundleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecsstream.ECSStreamBlockBundleRequest";
  }
  protected:
  explicit ECSStreamBlockBundleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorldAddressFieldNumber = 1,
    kBlockNumberFieldNumber = 2,
    kBlockHashFieldNumber = 3,
    kBlockTimestampFieldNumber = 4,
    kTransactionsConfirmedFieldNumber = 5,
    kEcsEventsFieldNumber = 6,
    kEcsEventsIncludeTxMetadataFieldNumber = 7,
  };
  // string worldAddress = 1;
  void clear_worldaddress();
  const std::string& worldaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_worldaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_worldaddress();
  PROTOBUF_NODISCARD std::string* release_worldaddress();
  void set_allocated_worldaddress(std::string* worldaddress);
  private:
  const std::string& _internal_worldaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_worldaddress(const std::string& value);
  std::string* _internal_mutable_worldaddress();
  public:

  // bool blockNumber = 2;
  void clear_blocknumber();
  bool blocknumber() const;
  void set_blocknumber(bool value);
  private:
  bool _internal_blocknumber() const;
  void _internal_set_blocknumber(bool value);
  public:

  // bool blockHash = 3;
  void clear_blockhash();
  bool blockhash() const;
  void set_blockhash(bool value);
  private:
  bool _internal_blockhash() const;
  void _internal_set_blockhash(bool value);
  public:

  // bool blockTimestamp = 4;
  void clear_blocktimestamp();
  bool blocktimestamp() const;
  void set_blocktimestamp(bool value);
  private:
  bool _internal_blocktimestamp() const;
  void _internal_set_blocktimestamp(bool value);
  public:

  // bool transactionsConfirmed = 5;
  void clear_transactionsconfirmed();
  bool transactionsconfirmed() const;
  void set_transactionsconfirmed(bool value);
  private:
  bool _internal_transactionsconfirmed() const;
  void _internal_set_transactionsconfirmed(bool value);
  public:

  // bool ecsEvents = 6;
  void clear_ecsevents();
  bool ecsevents() const;
  void set_ecsevents(bool value);
  private:
  bool _internal_ecsevents() const;
  void _internal_set_ecsevents(bool value);
  public:

  // bool ecsEventsIncludeTxMetadata = 7;
  void clear_ecseventsincludetxmetadata();
  bool ecseventsincludetxmetadata() const;
  void set_ecseventsincludetxmetadata(bool value);
  private:
  bool _internal_ecseventsincludetxmetadata() const;
  void _internal_set_ecseventsincludetxmetadata(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ecsstream.ECSStreamBlockBundleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr worldaddress_;
  bool blocknumber_;
  bool blockhash_;
  bool blocktimestamp_;
  bool transactionsconfirmed_;
  bool ecsevents_;
  bool ecseventsincludetxmetadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecs_5fstream_2eproto;
};
// -------------------------------------------------------------------

class ECSStreamBlockBundleReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecsstream.ECSStreamBlockBundleReply) */ {
 public:
  inline ECSStreamBlockBundleReply() : ECSStreamBlockBundleReply(nullptr) {}
  ~ECSStreamBlockBundleReply() override;
  explicit constexpr ECSStreamBlockBundleReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ECSStreamBlockBundleReply(const ECSStreamBlockBundleReply& from);
  ECSStreamBlockBundleReply(ECSStreamBlockBundleReply&& from) noexcept
    : ECSStreamBlockBundleReply() {
    *this = ::std::move(from);
  }

  inline ECSStreamBlockBundleReply& operator=(const ECSStreamBlockBundleReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ECSStreamBlockBundleReply& operator=(ECSStreamBlockBundleReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ECSStreamBlockBundleReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ECSStreamBlockBundleReply* internal_default_instance() {
    return reinterpret_cast<const ECSStreamBlockBundleReply*>(
               &_ECSStreamBlockBundleReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ECSStreamBlockBundleReply& a, ECSStreamBlockBundleReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ECSStreamBlockBundleReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ECSStreamBlockBundleReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ECSStreamBlockBundleReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ECSStreamBlockBundleReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ECSStreamBlockBundleReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ECSStreamBlockBundleReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ECSStreamBlockBundleReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecsstream.ECSStreamBlockBundleReply";
  }
  protected:
  explicit ECSStreamBlockBundleReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionsConfirmedFieldNumber = 4,
    kEcsEventsFieldNumber = 5,
    kBlockHashFieldNumber = 2,
    kBlockNumberFieldNumber = 1,
    kBlockTimestampFieldNumber = 3,
  };
  // repeated string transactionsConfirmed = 4;
  int transactionsconfirmed_size() const;
  private:
  int _internal_transactionsconfirmed_size() const;
  public:
  void clear_transactionsconfirmed();
  const std::string& transactionsconfirmed(int index) const;
  std::string* mutable_transactionsconfirmed(int index);
  void set_transactionsconfirmed(int index, const std::string& value);
  void set_transactionsconfirmed(int index, std::string&& value);
  void set_transactionsconfirmed(int index, const char* value);
  void set_transactionsconfirmed(int index, const char* value, size_t size);
  std::string* add_transactionsconfirmed();
  void add_transactionsconfirmed(const std::string& value);
  void add_transactionsconfirmed(std::string&& value);
  void add_transactionsconfirmed(const char* value);
  void add_transactionsconfirmed(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& transactionsconfirmed() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_transactionsconfirmed();
  private:
  const std::string& _internal_transactionsconfirmed(int index) const;
  std::string* _internal_add_transactionsconfirmed();
  public:

  // repeated .ecsstream.ECSEvent ecsEvents = 5;
  int ecsevents_size() const;
  private:
  int _internal_ecsevents_size() const;
  public:
  void clear_ecsevents();
  ::ecsstream::ECSEvent* mutable_ecsevents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ecsstream::ECSEvent >*
      mutable_ecsevents();
  private:
  const ::ecsstream::ECSEvent& _internal_ecsevents(int index) const;
  ::ecsstream::ECSEvent* _internal_add_ecsevents();
  public:
  const ::ecsstream::ECSEvent& ecsevents(int index) const;
  ::ecsstream::ECSEvent* add_ecsevents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ecsstream::ECSEvent >&
      ecsevents() const;

  // string blockHash = 2;
  void clear_blockhash();
  const std::string& blockhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blockhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blockhash();
  PROTOBUF_NODISCARD std::string* release_blockhash();
  void set_allocated_blockhash(std::string* blockhash);
  private:
  const std::string& _internal_blockhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blockhash(const std::string& value);
  std::string* _internal_mutable_blockhash();
  public:

  // uint32 blockNumber = 1;
  void clear_blocknumber();
  uint32_t blocknumber() const;
  void set_blocknumber(uint32_t value);
  private:
  uint32_t _internal_blocknumber() const;
  void _internal_set_blocknumber(uint32_t value);
  public:

  // uint32 blockTimestamp = 3;
  void clear_blocktimestamp();
  uint32_t blocktimestamp() const;
  void set_blocktimestamp(uint32_t value);
  private:
  uint32_t _internal_blocktimestamp() const;
  void _internal_set_blocktimestamp(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ecsstream.ECSStreamBlockBundleReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> transactionsconfirmed_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ecsstream::ECSEvent > ecsevents_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blockhash_;
  uint32_t blocknumber_;
  uint32_t blocktimestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecs_5fstream_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TxMetadata

// string to = 2;
inline void TxMetadata::clear_to() {
  to_.ClearToEmpty();
}
inline const std::string& TxMetadata::to() const {
  // @@protoc_insertion_point(field_get:ecsstream.TxMetadata.to)
  return _internal_to();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxMetadata::set_to(ArgT0&& arg0, ArgT... args) {
 
 to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ecsstream.TxMetadata.to)
}
inline std::string* TxMetadata::mutable_to() {
  std::string* _s = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:ecsstream.TxMetadata.to)
  return _s;
}
inline const std::string& TxMetadata::_internal_to() const {
  return to_.Get();
}
inline void TxMetadata::_internal_set_to(const std::string& value) {
  
  to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TxMetadata::_internal_mutable_to() {
  
  return to_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TxMetadata::release_to() {
  // @@protoc_insertion_point(field_release:ecsstream.TxMetadata.to)
  return to_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TxMetadata::set_allocated_to(std::string* to) {
  if (to != nullptr) {
    
  } else {
    
  }
  to_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (to_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    to_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ecsstream.TxMetadata.to)
}

// bytes data = 3;
inline void TxMetadata::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& TxMetadata::data() const {
  // @@protoc_insertion_point(field_get:ecsstream.TxMetadata.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxMetadata::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ecsstream.TxMetadata.data)
}
inline std::string* TxMetadata::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:ecsstream.TxMetadata.data)
  return _s;
}
inline const std::string& TxMetadata::_internal_data() const {
  return data_.Get();
}
inline void TxMetadata::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TxMetadata::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TxMetadata::release_data() {
  // @@protoc_insertion_point(field_release:ecsstream.TxMetadata.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TxMetadata::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ecsstream.TxMetadata.data)
}

// uint64 value = 4;
inline void TxMetadata::clear_value() {
  value_ = uint64_t{0u};
}
inline uint64_t TxMetadata::_internal_value() const {
  return value_;
}
inline uint64_t TxMetadata::value() const {
  // @@protoc_insertion_point(field_get:ecsstream.TxMetadata.value)
  return _internal_value();
}
inline void TxMetadata::_internal_set_value(uint64_t value) {
  
  value_ = value;
}
inline void TxMetadata::set_value(uint64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:ecsstream.TxMetadata.value)
}

// -------------------------------------------------------------------

// ECSEvent

// string eventType = 1;
inline void ECSEvent::clear_eventtype() {
  eventtype_.ClearToEmpty();
}
inline const std::string& ECSEvent::eventtype() const {
  // @@protoc_insertion_point(field_get:ecsstream.ECSEvent.eventType)
  return _internal_eventtype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ECSEvent::set_eventtype(ArgT0&& arg0, ArgT... args) {
 
 eventtype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ecsstream.ECSEvent.eventType)
}
inline std::string* ECSEvent::mutable_eventtype() {
  std::string* _s = _internal_mutable_eventtype();
  // @@protoc_insertion_point(field_mutable:ecsstream.ECSEvent.eventType)
  return _s;
}
inline const std::string& ECSEvent::_internal_eventtype() const {
  return eventtype_.Get();
}
inline void ECSEvent::_internal_set_eventtype(const std::string& value) {
  
  eventtype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ECSEvent::_internal_mutable_eventtype() {
  
  return eventtype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ECSEvent::release_eventtype() {
  // @@protoc_insertion_point(field_release:ecsstream.ECSEvent.eventType)
  return eventtype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ECSEvent::set_allocated_eventtype(std::string* eventtype) {
  if (eventtype != nullptr) {
    
  } else {
    
  }
  eventtype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), eventtype,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (eventtype_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    eventtype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ecsstream.ECSEvent.eventType)
}

// string componentId = 2;
inline void ECSEvent::clear_componentid() {
  componentid_.ClearToEmpty();
}
inline const std::string& ECSEvent::componentid() const {
  // @@protoc_insertion_point(field_get:ecsstream.ECSEvent.componentId)
  return _internal_componentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ECSEvent::set_componentid(ArgT0&& arg0, ArgT... args) {
 
 componentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ecsstream.ECSEvent.componentId)
}
inline std::string* ECSEvent::mutable_componentid() {
  std::string* _s = _internal_mutable_componentid();
  // @@protoc_insertion_point(field_mutable:ecsstream.ECSEvent.componentId)
  return _s;
}
inline const std::string& ECSEvent::_internal_componentid() const {
  return componentid_.Get();
}
inline void ECSEvent::_internal_set_componentid(const std::string& value) {
  
  componentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ECSEvent::_internal_mutable_componentid() {
  
  return componentid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ECSEvent::release_componentid() {
  // @@protoc_insertion_point(field_release:ecsstream.ECSEvent.componentId)
  return componentid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ECSEvent::set_allocated_componentid(std::string* componentid) {
  if (componentid != nullptr) {
    
  } else {
    
  }
  componentid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), componentid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (componentid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    componentid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ecsstream.ECSEvent.componentId)
}

// string entityId = 3;
inline void ECSEvent::clear_entityid() {
  entityid_.ClearToEmpty();
}
inline const std::string& ECSEvent::entityid() const {
  // @@protoc_insertion_point(field_get:ecsstream.ECSEvent.entityId)
  return _internal_entityid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ECSEvent::set_entityid(ArgT0&& arg0, ArgT... args) {
 
 entityid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ecsstream.ECSEvent.entityId)
}
inline std::string* ECSEvent::mutable_entityid() {
  std::string* _s = _internal_mutable_entityid();
  // @@protoc_insertion_point(field_mutable:ecsstream.ECSEvent.entityId)
  return _s;
}
inline const std::string& ECSEvent::_internal_entityid() const {
  return entityid_.Get();
}
inline void ECSEvent::_internal_set_entityid(const std::string& value) {
  
  entityid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ECSEvent::_internal_mutable_entityid() {
  
  return entityid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ECSEvent::release_entityid() {
  // @@protoc_insertion_point(field_release:ecsstream.ECSEvent.entityId)
  return entityid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ECSEvent::set_allocated_entityid(std::string* entityid) {
  if (entityid != nullptr) {
    
  } else {
    
  }
  entityid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), entityid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (entityid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    entityid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ecsstream.ECSEvent.entityId)
}

// bytes value = 4;
inline void ECSEvent::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& ECSEvent::value() const {
  // @@protoc_insertion_point(field_get:ecsstream.ECSEvent.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ECSEvent::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ecsstream.ECSEvent.value)
}
inline std::string* ECSEvent::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:ecsstream.ECSEvent.value)
  return _s;
}
inline const std::string& ECSEvent::_internal_value() const {
  return value_.Get();
}
inline void ECSEvent::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ECSEvent::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ECSEvent::release_value() {
  // @@protoc_insertion_point(field_release:ecsstream.ECSEvent.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ECSEvent::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ecsstream.ECSEvent.value)
}

// string txHash = 5;
inline void ECSEvent::clear_txhash() {
  txhash_.ClearToEmpty();
}
inline const std::string& ECSEvent::txhash() const {
  // @@protoc_insertion_point(field_get:ecsstream.ECSEvent.txHash)
  return _internal_txhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ECSEvent::set_txhash(ArgT0&& arg0, ArgT... args) {
 
 txhash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ecsstream.ECSEvent.txHash)
}
inline std::string* ECSEvent::mutable_txhash() {
  std::string* _s = _internal_mutable_txhash();
  // @@protoc_insertion_point(field_mutable:ecsstream.ECSEvent.txHash)
  return _s;
}
inline const std::string& ECSEvent::_internal_txhash() const {
  return txhash_.Get();
}
inline void ECSEvent::_internal_set_txhash(const std::string& value) {
  
  txhash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ECSEvent::_internal_mutable_txhash() {
  
  return txhash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ECSEvent::release_txhash() {
  // @@protoc_insertion_point(field_release:ecsstream.ECSEvent.txHash)
  return txhash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ECSEvent::set_allocated_txhash(std::string* txhash) {
  if (txhash != nullptr) {
    
  } else {
    
  }
  txhash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), txhash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (txhash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    txhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ecsstream.ECSEvent.txHash)
}

// .ecsstream.TxMetadata txMetadata = 6;
inline bool ECSEvent::_internal_has_txmetadata() const {
  return this != internal_default_instance() && txmetadata_ != nullptr;
}
inline bool ECSEvent::has_txmetadata() const {
  return _internal_has_txmetadata();
}
inline void ECSEvent::clear_txmetadata() {
  if (GetArenaForAllocation() == nullptr && txmetadata_ != nullptr) {
    delete txmetadata_;
  }
  txmetadata_ = nullptr;
}
inline const ::ecsstream::TxMetadata& ECSEvent::_internal_txmetadata() const {
  const ::ecsstream::TxMetadata* p = txmetadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::ecsstream::TxMetadata&>(
      ::ecsstream::_TxMetadata_default_instance_);
}
inline const ::ecsstream::TxMetadata& ECSEvent::txmetadata() const {
  // @@protoc_insertion_point(field_get:ecsstream.ECSEvent.txMetadata)
  return _internal_txmetadata();
}
inline void ECSEvent::unsafe_arena_set_allocated_txmetadata(
    ::ecsstream::TxMetadata* txmetadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(txmetadata_);
  }
  txmetadata_ = txmetadata;
  if (txmetadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ecsstream.ECSEvent.txMetadata)
}
inline ::ecsstream::TxMetadata* ECSEvent::release_txmetadata() {
  
  ::ecsstream::TxMetadata* temp = txmetadata_;
  txmetadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ecsstream::TxMetadata* ECSEvent::unsafe_arena_release_txmetadata() {
  // @@protoc_insertion_point(field_release:ecsstream.ECSEvent.txMetadata)
  
  ::ecsstream::TxMetadata* temp = txmetadata_;
  txmetadata_ = nullptr;
  return temp;
}
inline ::ecsstream::TxMetadata* ECSEvent::_internal_mutable_txmetadata() {
  
  if (txmetadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::ecsstream::TxMetadata>(GetArenaForAllocation());
    txmetadata_ = p;
  }
  return txmetadata_;
}
inline ::ecsstream::TxMetadata* ECSEvent::mutable_txmetadata() {
  ::ecsstream::TxMetadata* _msg = _internal_mutable_txmetadata();
  // @@protoc_insertion_point(field_mutable:ecsstream.ECSEvent.txMetadata)
  return _msg;
}
inline void ECSEvent::set_allocated_txmetadata(::ecsstream::TxMetadata* txmetadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete txmetadata_;
  }
  if (txmetadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ecsstream::TxMetadata>::GetOwningArena(txmetadata);
    if (message_arena != submessage_arena) {
      txmetadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, txmetadata, submessage_arena);
    }
    
  } else {
    
  }
  txmetadata_ = txmetadata;
  // @@protoc_insertion_point(field_set_allocated:ecsstream.ECSEvent.txMetadata)
}

// -------------------------------------------------------------------

// ECSStreamBlockBundleRequest

// string worldAddress = 1;
inline void ECSStreamBlockBundleRequest::clear_worldaddress() {
  worldaddress_.ClearToEmpty();
}
inline const std::string& ECSStreamBlockBundleRequest::worldaddress() const {
  // @@protoc_insertion_point(field_get:ecsstream.ECSStreamBlockBundleRequest.worldAddress)
  return _internal_worldaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ECSStreamBlockBundleRequest::set_worldaddress(ArgT0&& arg0, ArgT... args) {
 
 worldaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ecsstream.ECSStreamBlockBundleRequest.worldAddress)
}
inline std::string* ECSStreamBlockBundleRequest::mutable_worldaddress() {
  std::string* _s = _internal_mutable_worldaddress();
  // @@protoc_insertion_point(field_mutable:ecsstream.ECSStreamBlockBundleRequest.worldAddress)
  return _s;
}
inline const std::string& ECSStreamBlockBundleRequest::_internal_worldaddress() const {
  return worldaddress_.Get();
}
inline void ECSStreamBlockBundleRequest::_internal_set_worldaddress(const std::string& value) {
  
  worldaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ECSStreamBlockBundleRequest::_internal_mutable_worldaddress() {
  
  return worldaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ECSStreamBlockBundleRequest::release_worldaddress() {
  // @@protoc_insertion_point(field_release:ecsstream.ECSStreamBlockBundleRequest.worldAddress)
  return worldaddress_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ECSStreamBlockBundleRequest::set_allocated_worldaddress(std::string* worldaddress) {
  if (worldaddress != nullptr) {
    
  } else {
    
  }
  worldaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), worldaddress,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (worldaddress_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    worldaddress_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ecsstream.ECSStreamBlockBundleRequest.worldAddress)
}

// bool blockNumber = 2;
inline void ECSStreamBlockBundleRequest::clear_blocknumber() {
  blocknumber_ = false;
}
inline bool ECSStreamBlockBundleRequest::_internal_blocknumber() const {
  return blocknumber_;
}
inline bool ECSStreamBlockBundleRequest::blocknumber() const {
  // @@protoc_insertion_point(field_get:ecsstream.ECSStreamBlockBundleRequest.blockNumber)
  return _internal_blocknumber();
}
inline void ECSStreamBlockBundleRequest::_internal_set_blocknumber(bool value) {
  
  blocknumber_ = value;
}
inline void ECSStreamBlockBundleRequest::set_blocknumber(bool value) {
  _internal_set_blocknumber(value);
  // @@protoc_insertion_point(field_set:ecsstream.ECSStreamBlockBundleRequest.blockNumber)
}

// bool blockHash = 3;
inline void ECSStreamBlockBundleRequest::clear_blockhash() {
  blockhash_ = false;
}
inline bool ECSStreamBlockBundleRequest::_internal_blockhash() const {
  return blockhash_;
}
inline bool ECSStreamBlockBundleRequest::blockhash() const {
  // @@protoc_insertion_point(field_get:ecsstream.ECSStreamBlockBundleRequest.blockHash)
  return _internal_blockhash();
}
inline void ECSStreamBlockBundleRequest::_internal_set_blockhash(bool value) {
  
  blockhash_ = value;
}
inline void ECSStreamBlockBundleRequest::set_blockhash(bool value) {
  _internal_set_blockhash(value);
  // @@protoc_insertion_point(field_set:ecsstream.ECSStreamBlockBundleRequest.blockHash)
}

// bool blockTimestamp = 4;
inline void ECSStreamBlockBundleRequest::clear_blocktimestamp() {
  blocktimestamp_ = false;
}
inline bool ECSStreamBlockBundleRequest::_internal_blocktimestamp() const {
  return blocktimestamp_;
}
inline bool ECSStreamBlockBundleRequest::blocktimestamp() const {
  // @@protoc_insertion_point(field_get:ecsstream.ECSStreamBlockBundleRequest.blockTimestamp)
  return _internal_blocktimestamp();
}
inline void ECSStreamBlockBundleRequest::_internal_set_blocktimestamp(bool value) {
  
  blocktimestamp_ = value;
}
inline void ECSStreamBlockBundleRequest::set_blocktimestamp(bool value) {
  _internal_set_blocktimestamp(value);
  // @@protoc_insertion_point(field_set:ecsstream.ECSStreamBlockBundleRequest.blockTimestamp)
}

// bool transactionsConfirmed = 5;
inline void ECSStreamBlockBundleRequest::clear_transactionsconfirmed() {
  transactionsconfirmed_ = false;
}
inline bool ECSStreamBlockBundleRequest::_internal_transactionsconfirmed() const {
  return transactionsconfirmed_;
}
inline bool ECSStreamBlockBundleRequest::transactionsconfirmed() const {
  // @@protoc_insertion_point(field_get:ecsstream.ECSStreamBlockBundleRequest.transactionsConfirmed)
  return _internal_transactionsconfirmed();
}
inline void ECSStreamBlockBundleRequest::_internal_set_transactionsconfirmed(bool value) {
  
  transactionsconfirmed_ = value;
}
inline void ECSStreamBlockBundleRequest::set_transactionsconfirmed(bool value) {
  _internal_set_transactionsconfirmed(value);
  // @@protoc_insertion_point(field_set:ecsstream.ECSStreamBlockBundleRequest.transactionsConfirmed)
}

// bool ecsEvents = 6;
inline void ECSStreamBlockBundleRequest::clear_ecsevents() {
  ecsevents_ = false;
}
inline bool ECSStreamBlockBundleRequest::_internal_ecsevents() const {
  return ecsevents_;
}
inline bool ECSStreamBlockBundleRequest::ecsevents() const {
  // @@protoc_insertion_point(field_get:ecsstream.ECSStreamBlockBundleRequest.ecsEvents)
  return _internal_ecsevents();
}
inline void ECSStreamBlockBundleRequest::_internal_set_ecsevents(bool value) {
  
  ecsevents_ = value;
}
inline void ECSStreamBlockBundleRequest::set_ecsevents(bool value) {
  _internal_set_ecsevents(value);
  // @@protoc_insertion_point(field_set:ecsstream.ECSStreamBlockBundleRequest.ecsEvents)
}

// bool ecsEventsIncludeTxMetadata = 7;
inline void ECSStreamBlockBundleRequest::clear_ecseventsincludetxmetadata() {
  ecseventsincludetxmetadata_ = false;
}
inline bool ECSStreamBlockBundleRequest::_internal_ecseventsincludetxmetadata() const {
  return ecseventsincludetxmetadata_;
}
inline bool ECSStreamBlockBundleRequest::ecseventsincludetxmetadata() const {
  // @@protoc_insertion_point(field_get:ecsstream.ECSStreamBlockBundleRequest.ecsEventsIncludeTxMetadata)
  return _internal_ecseventsincludetxmetadata();
}
inline void ECSStreamBlockBundleRequest::_internal_set_ecseventsincludetxmetadata(bool value) {
  
  ecseventsincludetxmetadata_ = value;
}
inline void ECSStreamBlockBundleRequest::set_ecseventsincludetxmetadata(bool value) {
  _internal_set_ecseventsincludetxmetadata(value);
  // @@protoc_insertion_point(field_set:ecsstream.ECSStreamBlockBundleRequest.ecsEventsIncludeTxMetadata)
}

// -------------------------------------------------------------------

// ECSStreamBlockBundleReply

// uint32 blockNumber = 1;
inline void ECSStreamBlockBundleReply::clear_blocknumber() {
  blocknumber_ = 0u;
}
inline uint32_t ECSStreamBlockBundleReply::_internal_blocknumber() const {
  return blocknumber_;
}
inline uint32_t ECSStreamBlockBundleReply::blocknumber() const {
  // @@protoc_insertion_point(field_get:ecsstream.ECSStreamBlockBundleReply.blockNumber)
  return _internal_blocknumber();
}
inline void ECSStreamBlockBundleReply::_internal_set_blocknumber(uint32_t value) {
  
  blocknumber_ = value;
}
inline void ECSStreamBlockBundleReply::set_blocknumber(uint32_t value) {
  _internal_set_blocknumber(value);
  // @@protoc_insertion_point(field_set:ecsstream.ECSStreamBlockBundleReply.blockNumber)
}

// string blockHash = 2;
inline void ECSStreamBlockBundleReply::clear_blockhash() {
  blockhash_.ClearToEmpty();
}
inline const std::string& ECSStreamBlockBundleReply::blockhash() const {
  // @@protoc_insertion_point(field_get:ecsstream.ECSStreamBlockBundleReply.blockHash)
  return _internal_blockhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ECSStreamBlockBundleReply::set_blockhash(ArgT0&& arg0, ArgT... args) {
 
 blockhash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ecsstream.ECSStreamBlockBundleReply.blockHash)
}
inline std::string* ECSStreamBlockBundleReply::mutable_blockhash() {
  std::string* _s = _internal_mutable_blockhash();
  // @@protoc_insertion_point(field_mutable:ecsstream.ECSStreamBlockBundleReply.blockHash)
  return _s;
}
inline const std::string& ECSStreamBlockBundleReply::_internal_blockhash() const {
  return blockhash_.Get();
}
inline void ECSStreamBlockBundleReply::_internal_set_blockhash(const std::string& value) {
  
  blockhash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ECSStreamBlockBundleReply::_internal_mutable_blockhash() {
  
  return blockhash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ECSStreamBlockBundleReply::release_blockhash() {
  // @@protoc_insertion_point(field_release:ecsstream.ECSStreamBlockBundleReply.blockHash)
  return blockhash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ECSStreamBlockBundleReply::set_allocated_blockhash(std::string* blockhash) {
  if (blockhash != nullptr) {
    
  } else {
    
  }
  blockhash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), blockhash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (blockhash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    blockhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ecsstream.ECSStreamBlockBundleReply.blockHash)
}

// uint32 blockTimestamp = 3;
inline void ECSStreamBlockBundleReply::clear_blocktimestamp() {
  blocktimestamp_ = 0u;
}
inline uint32_t ECSStreamBlockBundleReply::_internal_blocktimestamp() const {
  return blocktimestamp_;
}
inline uint32_t ECSStreamBlockBundleReply::blocktimestamp() const {
  // @@protoc_insertion_point(field_get:ecsstream.ECSStreamBlockBundleReply.blockTimestamp)
  return _internal_blocktimestamp();
}
inline void ECSStreamBlockBundleReply::_internal_set_blocktimestamp(uint32_t value) {
  
  blocktimestamp_ = value;
}
inline void ECSStreamBlockBundleReply::set_blocktimestamp(uint32_t value) {
  _internal_set_blocktimestamp(value);
  // @@protoc_insertion_point(field_set:ecsstream.ECSStreamBlockBundleReply.blockTimestamp)
}

// repeated string transactionsConfirmed = 4;
inline int ECSStreamBlockBundleReply::_internal_transactionsconfirmed_size() const {
  return transactionsconfirmed_.size();
}
inline int ECSStreamBlockBundleReply::transactionsconfirmed_size() const {
  return _internal_transactionsconfirmed_size();
}
inline void ECSStreamBlockBundleReply::clear_transactionsconfirmed() {
  transactionsconfirmed_.Clear();
}
inline std::string* ECSStreamBlockBundleReply::add_transactionsconfirmed() {
  std::string* _s = _internal_add_transactionsconfirmed();
  // @@protoc_insertion_point(field_add_mutable:ecsstream.ECSStreamBlockBundleReply.transactionsConfirmed)
  return _s;
}
inline const std::string& ECSStreamBlockBundleReply::_internal_transactionsconfirmed(int index) const {
  return transactionsconfirmed_.Get(index);
}
inline const std::string& ECSStreamBlockBundleReply::transactionsconfirmed(int index) const {
  // @@protoc_insertion_point(field_get:ecsstream.ECSStreamBlockBundleReply.transactionsConfirmed)
  return _internal_transactionsconfirmed(index);
}
inline std::string* ECSStreamBlockBundleReply::mutable_transactionsconfirmed(int index) {
  // @@protoc_insertion_point(field_mutable:ecsstream.ECSStreamBlockBundleReply.transactionsConfirmed)
  return transactionsconfirmed_.Mutable(index);
}
inline void ECSStreamBlockBundleReply::set_transactionsconfirmed(int index, const std::string& value) {
  transactionsconfirmed_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ecsstream.ECSStreamBlockBundleReply.transactionsConfirmed)
}
inline void ECSStreamBlockBundleReply::set_transactionsconfirmed(int index, std::string&& value) {
  transactionsconfirmed_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ecsstream.ECSStreamBlockBundleReply.transactionsConfirmed)
}
inline void ECSStreamBlockBundleReply::set_transactionsconfirmed(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  transactionsconfirmed_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ecsstream.ECSStreamBlockBundleReply.transactionsConfirmed)
}
inline void ECSStreamBlockBundleReply::set_transactionsconfirmed(int index, const char* value, size_t size) {
  transactionsconfirmed_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecsstream.ECSStreamBlockBundleReply.transactionsConfirmed)
}
inline std::string* ECSStreamBlockBundleReply::_internal_add_transactionsconfirmed() {
  return transactionsconfirmed_.Add();
}
inline void ECSStreamBlockBundleReply::add_transactionsconfirmed(const std::string& value) {
  transactionsconfirmed_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ecsstream.ECSStreamBlockBundleReply.transactionsConfirmed)
}
inline void ECSStreamBlockBundleReply::add_transactionsconfirmed(std::string&& value) {
  transactionsconfirmed_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ecsstream.ECSStreamBlockBundleReply.transactionsConfirmed)
}
inline void ECSStreamBlockBundleReply::add_transactionsconfirmed(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  transactionsconfirmed_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ecsstream.ECSStreamBlockBundleReply.transactionsConfirmed)
}
inline void ECSStreamBlockBundleReply::add_transactionsconfirmed(const char* value, size_t size) {
  transactionsconfirmed_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ecsstream.ECSStreamBlockBundleReply.transactionsConfirmed)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ECSStreamBlockBundleReply::transactionsconfirmed() const {
  // @@protoc_insertion_point(field_list:ecsstream.ECSStreamBlockBundleReply.transactionsConfirmed)
  return transactionsconfirmed_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ECSStreamBlockBundleReply::mutable_transactionsconfirmed() {
  // @@protoc_insertion_point(field_mutable_list:ecsstream.ECSStreamBlockBundleReply.transactionsConfirmed)
  return &transactionsconfirmed_;
}

// repeated .ecsstream.ECSEvent ecsEvents = 5;
inline int ECSStreamBlockBundleReply::_internal_ecsevents_size() const {
  return ecsevents_.size();
}
inline int ECSStreamBlockBundleReply::ecsevents_size() const {
  return _internal_ecsevents_size();
}
inline void ECSStreamBlockBundleReply::clear_ecsevents() {
  ecsevents_.Clear();
}
inline ::ecsstream::ECSEvent* ECSStreamBlockBundleReply::mutable_ecsevents(int index) {
  // @@protoc_insertion_point(field_mutable:ecsstream.ECSStreamBlockBundleReply.ecsEvents)
  return ecsevents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ecsstream::ECSEvent >*
ECSStreamBlockBundleReply::mutable_ecsevents() {
  // @@protoc_insertion_point(field_mutable_list:ecsstream.ECSStreamBlockBundleReply.ecsEvents)
  return &ecsevents_;
}
inline const ::ecsstream::ECSEvent& ECSStreamBlockBundleReply::_internal_ecsevents(int index) const {
  return ecsevents_.Get(index);
}
inline const ::ecsstream::ECSEvent& ECSStreamBlockBundleReply::ecsevents(int index) const {
  // @@protoc_insertion_point(field_get:ecsstream.ECSStreamBlockBundleReply.ecsEvents)
  return _internal_ecsevents(index);
}
inline ::ecsstream::ECSEvent* ECSStreamBlockBundleReply::_internal_add_ecsevents() {
  return ecsevents_.Add();
}
inline ::ecsstream::ECSEvent* ECSStreamBlockBundleReply::add_ecsevents() {
  ::ecsstream::ECSEvent* _add = _internal_add_ecsevents();
  // @@protoc_insertion_point(field_add:ecsstream.ECSStreamBlockBundleReply.ecsEvents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ecsstream::ECSEvent >&
ECSStreamBlockBundleReply::ecsevents() const {
  // @@protoc_insertion_point(field_list:ecsstream.ECSStreamBlockBundleReply.ecsEvents)
  return ecsevents_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ecsstream

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ecs_5fstream_2eproto
