// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: ecs_snapshot.proto
#ifndef GRPC_ecs_5fsnapshot_2eproto__INCLUDED
#define GRPC_ecs_5fsnapshot_2eproto__INCLUDED

#include "ecs_snapshot.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace ecssnapshot {

// The Snapshot Service definition.
class ECSStateSnapshotService final {
 public:
  static constexpr char const* service_full_name() {
    return "ecssnapshot.ECSStateSnapshotService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Requests the latest ECS state.
    virtual ::grpc::Status GetStateLatest(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatest& request, ::ecssnapshot::ECSStateReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::ECSStateReply>> AsyncGetStateLatest(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::ECSStateReply>>(AsyncGetStateLatestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::ECSStateReply>> PrepareAsyncGetStateLatest(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::ECSStateReply>>(PrepareAsyncGetStateLatestRaw(context, request, cq));
    }
    // Requests the latest ECS state in stream format, which will chunk the state.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::ecssnapshot::ECSStateReply>> GetStateLatestStream(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::ecssnapshot::ECSStateReply>>(GetStateLatestStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReply>> AsyncGetStateLatestStream(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReply>>(AsyncGetStateLatestStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReply>> PrepareAsyncGetStateLatestStream(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReply>>(PrepareAsyncGetStateLatestStreamRaw(context, request, cq));
    }
    // Requests the latest ECS state in stream format, which will chunk the state.
    // 
    // V2 version optimized to return entities as raw bytes.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::ecssnapshot::ECSStateReplyV2>> GetStateLatestStreamV2(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::ecssnapshot::ECSStateReplyV2>>(GetStateLatestStreamV2Raw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReplyV2>> AsyncGetStateLatestStreamV2(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReplyV2>>(AsyncGetStateLatestStreamV2Raw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReplyV2>> PrepareAsyncGetStateLatestStreamV2(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReplyV2>>(PrepareAsyncGetStateLatestStreamV2Raw(context, request, cq));
    }
    // Requests the latest ECS state, with aditional pruning.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::ecssnapshot::ECSStateReply>> GetStateLatestStreamPruned(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::ecssnapshot::ECSStateReply>>(GetStateLatestStreamPrunedRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReply>> AsyncGetStateLatestStreamPruned(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReply>>(AsyncGetStateLatestStreamPrunedRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReply>> PrepareAsyncGetStateLatestStreamPruned(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReply>>(PrepareAsyncGetStateLatestStreamPrunedRaw(context, request, cq));
    }
    // Requests the latest ECS state, with aditional pruning.
    // 
    // V2 version optimized to return entities as raw bytes.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::ecssnapshot::ECSStateReplyV2>> GetStateLatestStreamPrunedV2(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::ecssnapshot::ECSStateReplyV2>>(GetStateLatestStreamPrunedV2Raw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReplyV2>> AsyncGetStateLatestStreamPrunedV2(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReplyV2>>(AsyncGetStateLatestStreamPrunedV2Raw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReplyV2>> PrepareAsyncGetStateLatestStreamPrunedV2(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReplyV2>>(PrepareAsyncGetStateLatestStreamPrunedV2Raw(context, request, cq));
    }
    // Requests the latest block number based on the latest ECS state.
    virtual ::grpc::Status GetStateBlockLatest(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateBlockRequestLatest& request, ::ecssnapshot::ECSStateBlockReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::ECSStateBlockReply>> AsyncGetStateBlockLatest(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateBlockRequestLatest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::ECSStateBlockReply>>(AsyncGetStateBlockLatestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::ECSStateBlockReply>> PrepareAsyncGetStateBlockLatest(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateBlockRequestLatest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::ECSStateBlockReply>>(PrepareAsyncGetStateBlockLatestRaw(context, request, cq));
    }
    // Requests the ECS state at specific block.
    virtual ::grpc::Status GetStateAtBlock(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestAtBlock& request, ::ecssnapshot::ECSStateReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::ECSStateReply>> AsyncGetStateAtBlock(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestAtBlock& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::ECSStateReply>>(AsyncGetStateAtBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::ECSStateReply>> PrepareAsyncGetStateAtBlock(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestAtBlock& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::ECSStateReply>>(PrepareAsyncGetStateAtBlockRaw(context, request, cq));
    }
    // Requests a list of known worlds based on chain state.
    virtual ::grpc::Status GetWorlds(::grpc::ClientContext* context, const ::ecssnapshot::WorldsRequest& request, ::ecssnapshot::Worlds* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::Worlds>> AsyncGetWorlds(::grpc::ClientContext* context, const ::ecssnapshot::WorldsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::Worlds>>(AsyncGetWorldsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::Worlds>> PrepareAsyncGetWorlds(::grpc::ClientContext* context, const ::ecssnapshot::WorldsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::Worlds>>(PrepareAsyncGetWorldsRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Requests the latest ECS state.
      virtual void GetStateLatest(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatest* request, ::ecssnapshot::ECSStateReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetStateLatest(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatest* request, ::ecssnapshot::ECSStateReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Requests the latest ECS state in stream format, which will chunk the state.
      virtual void GetStateLatestStream(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream* request, ::grpc::ClientReadReactor< ::ecssnapshot::ECSStateReply>* reactor) = 0;
      // Requests the latest ECS state in stream format, which will chunk the state.
      // 
      // V2 version optimized to return entities as raw bytes.
      virtual void GetStateLatestStreamV2(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream* request, ::grpc::ClientReadReactor< ::ecssnapshot::ECSStateReplyV2>* reactor) = 0;
      // Requests the latest ECS state, with aditional pruning.
      virtual void GetStateLatestStreamPruned(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned* request, ::grpc::ClientReadReactor< ::ecssnapshot::ECSStateReply>* reactor) = 0;
      // Requests the latest ECS state, with aditional pruning.
      // 
      // V2 version optimized to return entities as raw bytes.
      virtual void GetStateLatestStreamPrunedV2(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned* request, ::grpc::ClientReadReactor< ::ecssnapshot::ECSStateReplyV2>* reactor) = 0;
      // Requests the latest block number based on the latest ECS state.
      virtual void GetStateBlockLatest(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateBlockRequestLatest* request, ::ecssnapshot::ECSStateBlockReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetStateBlockLatest(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateBlockRequestLatest* request, ::ecssnapshot::ECSStateBlockReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Requests the ECS state at specific block.
      virtual void GetStateAtBlock(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestAtBlock* request, ::ecssnapshot::ECSStateReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetStateAtBlock(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestAtBlock* request, ::ecssnapshot::ECSStateReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Requests a list of known worlds based on chain state.
      virtual void GetWorlds(::grpc::ClientContext* context, const ::ecssnapshot::WorldsRequest* request, ::ecssnapshot::Worlds* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetWorlds(::grpc::ClientContext* context, const ::ecssnapshot::WorldsRequest* request, ::ecssnapshot::Worlds* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::ECSStateReply>* AsyncGetStateLatestRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::ECSStateReply>* PrepareAsyncGetStateLatestRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::ecssnapshot::ECSStateReply>* GetStateLatestStreamRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReply>* AsyncGetStateLatestStreamRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReply>* PrepareAsyncGetStateLatestStreamRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::ecssnapshot::ECSStateReplyV2>* GetStateLatestStreamV2Raw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReplyV2>* AsyncGetStateLatestStreamV2Raw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReplyV2>* PrepareAsyncGetStateLatestStreamV2Raw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::ecssnapshot::ECSStateReply>* GetStateLatestStreamPrunedRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReply>* AsyncGetStateLatestStreamPrunedRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReply>* PrepareAsyncGetStateLatestStreamPrunedRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::ecssnapshot::ECSStateReplyV2>* GetStateLatestStreamPrunedV2Raw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReplyV2>* AsyncGetStateLatestStreamPrunedV2Raw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::ecssnapshot::ECSStateReplyV2>* PrepareAsyncGetStateLatestStreamPrunedV2Raw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::ECSStateBlockReply>* AsyncGetStateBlockLatestRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateBlockRequestLatest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::ECSStateBlockReply>* PrepareAsyncGetStateBlockLatestRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateBlockRequestLatest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::ECSStateReply>* AsyncGetStateAtBlockRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestAtBlock& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::ECSStateReply>* PrepareAsyncGetStateAtBlockRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestAtBlock& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::Worlds>* AsyncGetWorldsRaw(::grpc::ClientContext* context, const ::ecssnapshot::WorldsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ecssnapshot::Worlds>* PrepareAsyncGetWorldsRaw(::grpc::ClientContext* context, const ::ecssnapshot::WorldsRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status GetStateLatest(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatest& request, ::ecssnapshot::ECSStateReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ecssnapshot::ECSStateReply>> AsyncGetStateLatest(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ecssnapshot::ECSStateReply>>(AsyncGetStateLatestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ecssnapshot::ECSStateReply>> PrepareAsyncGetStateLatest(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ecssnapshot::ECSStateReply>>(PrepareAsyncGetStateLatestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::ecssnapshot::ECSStateReply>> GetStateLatestStream(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::ecssnapshot::ECSStateReply>>(GetStateLatestStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReply>> AsyncGetStateLatestStream(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReply>>(AsyncGetStateLatestStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReply>> PrepareAsyncGetStateLatestStream(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReply>>(PrepareAsyncGetStateLatestStreamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::ecssnapshot::ECSStateReplyV2>> GetStateLatestStreamV2(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::ecssnapshot::ECSStateReplyV2>>(GetStateLatestStreamV2Raw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReplyV2>> AsyncGetStateLatestStreamV2(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReplyV2>>(AsyncGetStateLatestStreamV2Raw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReplyV2>> PrepareAsyncGetStateLatestStreamV2(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReplyV2>>(PrepareAsyncGetStateLatestStreamV2Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::ecssnapshot::ECSStateReply>> GetStateLatestStreamPruned(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::ecssnapshot::ECSStateReply>>(GetStateLatestStreamPrunedRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReply>> AsyncGetStateLatestStreamPruned(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReply>>(AsyncGetStateLatestStreamPrunedRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReply>> PrepareAsyncGetStateLatestStreamPruned(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReply>>(PrepareAsyncGetStateLatestStreamPrunedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::ecssnapshot::ECSStateReplyV2>> GetStateLatestStreamPrunedV2(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::ecssnapshot::ECSStateReplyV2>>(GetStateLatestStreamPrunedV2Raw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReplyV2>> AsyncGetStateLatestStreamPrunedV2(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReplyV2>>(AsyncGetStateLatestStreamPrunedV2Raw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReplyV2>> PrepareAsyncGetStateLatestStreamPrunedV2(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReplyV2>>(PrepareAsyncGetStateLatestStreamPrunedV2Raw(context, request, cq));
    }
    ::grpc::Status GetStateBlockLatest(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateBlockRequestLatest& request, ::ecssnapshot::ECSStateBlockReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ecssnapshot::ECSStateBlockReply>> AsyncGetStateBlockLatest(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateBlockRequestLatest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ecssnapshot::ECSStateBlockReply>>(AsyncGetStateBlockLatestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ecssnapshot::ECSStateBlockReply>> PrepareAsyncGetStateBlockLatest(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateBlockRequestLatest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ecssnapshot::ECSStateBlockReply>>(PrepareAsyncGetStateBlockLatestRaw(context, request, cq));
    }
    ::grpc::Status GetStateAtBlock(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestAtBlock& request, ::ecssnapshot::ECSStateReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ecssnapshot::ECSStateReply>> AsyncGetStateAtBlock(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestAtBlock& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ecssnapshot::ECSStateReply>>(AsyncGetStateAtBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ecssnapshot::ECSStateReply>> PrepareAsyncGetStateAtBlock(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestAtBlock& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ecssnapshot::ECSStateReply>>(PrepareAsyncGetStateAtBlockRaw(context, request, cq));
    }
    ::grpc::Status GetWorlds(::grpc::ClientContext* context, const ::ecssnapshot::WorldsRequest& request, ::ecssnapshot::Worlds* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ecssnapshot::Worlds>> AsyncGetWorlds(::grpc::ClientContext* context, const ::ecssnapshot::WorldsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ecssnapshot::Worlds>>(AsyncGetWorldsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ecssnapshot::Worlds>> PrepareAsyncGetWorlds(::grpc::ClientContext* context, const ::ecssnapshot::WorldsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ecssnapshot::Worlds>>(PrepareAsyncGetWorldsRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void GetStateLatest(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatest* request, ::ecssnapshot::ECSStateReply* response, std::function<void(::grpc::Status)>) override;
      void GetStateLatest(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatest* request, ::ecssnapshot::ECSStateReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetStateLatestStream(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream* request, ::grpc::ClientReadReactor< ::ecssnapshot::ECSStateReply>* reactor) override;
      void GetStateLatestStreamV2(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream* request, ::grpc::ClientReadReactor< ::ecssnapshot::ECSStateReplyV2>* reactor) override;
      void GetStateLatestStreamPruned(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned* request, ::grpc::ClientReadReactor< ::ecssnapshot::ECSStateReply>* reactor) override;
      void GetStateLatestStreamPrunedV2(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned* request, ::grpc::ClientReadReactor< ::ecssnapshot::ECSStateReplyV2>* reactor) override;
      void GetStateBlockLatest(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateBlockRequestLatest* request, ::ecssnapshot::ECSStateBlockReply* response, std::function<void(::grpc::Status)>) override;
      void GetStateBlockLatest(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateBlockRequestLatest* request, ::ecssnapshot::ECSStateBlockReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetStateAtBlock(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestAtBlock* request, ::ecssnapshot::ECSStateReply* response, std::function<void(::grpc::Status)>) override;
      void GetStateAtBlock(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestAtBlock* request, ::ecssnapshot::ECSStateReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetWorlds(::grpc::ClientContext* context, const ::ecssnapshot::WorldsRequest* request, ::ecssnapshot::Worlds* response, std::function<void(::grpc::Status)>) override;
      void GetWorlds(::grpc::ClientContext* context, const ::ecssnapshot::WorldsRequest* request, ::ecssnapshot::Worlds* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::ecssnapshot::ECSStateReply>* AsyncGetStateLatestRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ecssnapshot::ECSStateReply>* PrepareAsyncGetStateLatestRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::ecssnapshot::ECSStateReply>* GetStateLatestStreamRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request) override;
    ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReply>* AsyncGetStateLatestStreamRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReply>* PrepareAsyncGetStateLatestStreamRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::ecssnapshot::ECSStateReplyV2>* GetStateLatestStreamV2Raw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request) override;
    ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReplyV2>* AsyncGetStateLatestStreamV2Raw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReplyV2>* PrepareAsyncGetStateLatestStreamV2Raw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStream& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::ecssnapshot::ECSStateReply>* GetStateLatestStreamPrunedRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request) override;
    ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReply>* AsyncGetStateLatestStreamPrunedRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReply>* PrepareAsyncGetStateLatestStreamPrunedRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::ecssnapshot::ECSStateReplyV2>* GetStateLatestStreamPrunedV2Raw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request) override;
    ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReplyV2>* AsyncGetStateLatestStreamPrunedV2Raw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::ecssnapshot::ECSStateReplyV2>* PrepareAsyncGetStateLatestStreamPrunedV2Raw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ecssnapshot::ECSStateBlockReply>* AsyncGetStateBlockLatestRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateBlockRequestLatest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ecssnapshot::ECSStateBlockReply>* PrepareAsyncGetStateBlockLatestRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateBlockRequestLatest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ecssnapshot::ECSStateReply>* AsyncGetStateAtBlockRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestAtBlock& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ecssnapshot::ECSStateReply>* PrepareAsyncGetStateAtBlockRaw(::grpc::ClientContext* context, const ::ecssnapshot::ECSStateRequestAtBlock& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ecssnapshot::Worlds>* AsyncGetWorldsRaw(::grpc::ClientContext* context, const ::ecssnapshot::WorldsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ecssnapshot::Worlds>* PrepareAsyncGetWorldsRaw(::grpc::ClientContext* context, const ::ecssnapshot::WorldsRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetStateLatest_;
    const ::grpc::internal::RpcMethod rpcmethod_GetStateLatestStream_;
    const ::grpc::internal::RpcMethod rpcmethod_GetStateLatestStreamV2_;
    const ::grpc::internal::RpcMethod rpcmethod_GetStateLatestStreamPruned_;
    const ::grpc::internal::RpcMethod rpcmethod_GetStateLatestStreamPrunedV2_;
    const ::grpc::internal::RpcMethod rpcmethod_GetStateBlockLatest_;
    const ::grpc::internal::RpcMethod rpcmethod_GetStateAtBlock_;
    const ::grpc::internal::RpcMethod rpcmethod_GetWorlds_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Requests the latest ECS state.
    virtual ::grpc::Status GetStateLatest(::grpc::ServerContext* context, const ::ecssnapshot::ECSStateRequestLatest* request, ::ecssnapshot::ECSStateReply* response);
    // Requests the latest ECS state in stream format, which will chunk the state.
    virtual ::grpc::Status GetStateLatestStream(::grpc::ServerContext* context, const ::ecssnapshot::ECSStateRequestLatestStream* request, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReply>* writer);
    // Requests the latest ECS state in stream format, which will chunk the state.
    // 
    // V2 version optimized to return entities as raw bytes.
    virtual ::grpc::Status GetStateLatestStreamV2(::grpc::ServerContext* context, const ::ecssnapshot::ECSStateRequestLatestStream* request, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReplyV2>* writer);
    // Requests the latest ECS state, with aditional pruning.
    virtual ::grpc::Status GetStateLatestStreamPruned(::grpc::ServerContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned* request, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReply>* writer);
    // Requests the latest ECS state, with aditional pruning.
    // 
    // V2 version optimized to return entities as raw bytes.
    virtual ::grpc::Status GetStateLatestStreamPrunedV2(::grpc::ServerContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned* request, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReplyV2>* writer);
    // Requests the latest block number based on the latest ECS state.
    virtual ::grpc::Status GetStateBlockLatest(::grpc::ServerContext* context, const ::ecssnapshot::ECSStateBlockRequestLatest* request, ::ecssnapshot::ECSStateBlockReply* response);
    // Requests the ECS state at specific block.
    virtual ::grpc::Status GetStateAtBlock(::grpc::ServerContext* context, const ::ecssnapshot::ECSStateRequestAtBlock* request, ::ecssnapshot::ECSStateReply* response);
    // Requests a list of known worlds based on chain state.
    virtual ::grpc::Status GetWorlds(::grpc::ServerContext* context, const ::ecssnapshot::WorldsRequest* request, ::ecssnapshot::Worlds* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetStateLatest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetStateLatest() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetStateLatest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatest(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatest* /*request*/, ::ecssnapshot::ECSStateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStateLatest(::grpc::ServerContext* context, ::ecssnapshot::ECSStateRequestLatest* request, ::grpc::ServerAsyncResponseWriter< ::ecssnapshot::ECSStateReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetStateLatestStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetStateLatestStream() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetStateLatestStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatestStream(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStream* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStateLatestStream(::grpc::ServerContext* context, ::ecssnapshot::ECSStateRequestLatestStream* request, ::grpc::ServerAsyncWriter< ::ecssnapshot::ECSStateReply>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetStateLatestStreamV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetStateLatestStreamV2() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetStateLatestStreamV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatestStreamV2(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStream* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReplyV2>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStateLatestStreamV2(::grpc::ServerContext* context, ::ecssnapshot::ECSStateRequestLatestStream* request, ::grpc::ServerAsyncWriter< ::ecssnapshot::ECSStateReplyV2>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetStateLatestStreamPruned : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetStateLatestStreamPruned() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetStateLatestStreamPruned() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatestStreamPruned(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStreamPruned* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStateLatestStreamPruned(::grpc::ServerContext* context, ::ecssnapshot::ECSStateRequestLatestStreamPruned* request, ::grpc::ServerAsyncWriter< ::ecssnapshot::ECSStateReply>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetStateLatestStreamPrunedV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetStateLatestStreamPrunedV2() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetStateLatestStreamPrunedV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatestStreamPrunedV2(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStreamPruned* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReplyV2>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStateLatestStreamPrunedV2(::grpc::ServerContext* context, ::ecssnapshot::ECSStateRequestLatestStreamPruned* request, ::grpc::ServerAsyncWriter< ::ecssnapshot::ECSStateReplyV2>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(4, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetStateBlockLatest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetStateBlockLatest() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetStateBlockLatest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateBlockLatest(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateBlockRequestLatest* /*request*/, ::ecssnapshot::ECSStateBlockReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStateBlockLatest(::grpc::ServerContext* context, ::ecssnapshot::ECSStateBlockRequestLatest* request, ::grpc::ServerAsyncResponseWriter< ::ecssnapshot::ECSStateBlockReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetStateAtBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetStateAtBlock() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetStateAtBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateAtBlock(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestAtBlock* /*request*/, ::ecssnapshot::ECSStateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStateAtBlock(::grpc::ServerContext* context, ::ecssnapshot::ECSStateRequestAtBlock* request, ::grpc::ServerAsyncResponseWriter< ::ecssnapshot::ECSStateReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetWorlds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetWorlds() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetWorlds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorlds(::grpc::ServerContext* /*context*/, const ::ecssnapshot::WorldsRequest* /*request*/, ::ecssnapshot::Worlds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWorlds(::grpc::ServerContext* context, ::ecssnapshot::WorldsRequest* request, ::grpc::ServerAsyncResponseWriter< ::ecssnapshot::Worlds>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetStateLatest<WithAsyncMethod_GetStateLatestStream<WithAsyncMethod_GetStateLatestStreamV2<WithAsyncMethod_GetStateLatestStreamPruned<WithAsyncMethod_GetStateLatestStreamPrunedV2<WithAsyncMethod_GetStateBlockLatest<WithAsyncMethod_GetStateAtBlock<WithAsyncMethod_GetWorlds<Service > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_GetStateLatest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetStateLatest() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::ecssnapshot::ECSStateRequestLatest, ::ecssnapshot::ECSStateReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ecssnapshot::ECSStateRequestLatest* request, ::ecssnapshot::ECSStateReply* response) { return this->GetStateLatest(context, request, response); }));}
    void SetMessageAllocatorFor_GetStateLatest(
        ::grpc::MessageAllocator< ::ecssnapshot::ECSStateRequestLatest, ::ecssnapshot::ECSStateReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ecssnapshot::ECSStateRequestLatest, ::ecssnapshot::ECSStateReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetStateLatest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatest(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatest* /*request*/, ::ecssnapshot::ECSStateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetStateLatest(
      ::grpc::CallbackServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatest* /*request*/, ::ecssnapshot::ECSStateReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetStateLatestStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetStateLatestStream() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackServerStreamingHandler< ::ecssnapshot::ECSStateRequestLatestStream, ::ecssnapshot::ECSStateReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ecssnapshot::ECSStateRequestLatestStream* request) { return this->GetStateLatestStream(context, request); }));
    }
    ~WithCallbackMethod_GetStateLatestStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatestStream(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStream* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::ecssnapshot::ECSStateReply>* GetStateLatestStream(
      ::grpc::CallbackServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStream* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetStateLatestStreamV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetStateLatestStreamV2() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackServerStreamingHandler< ::ecssnapshot::ECSStateRequestLatestStream, ::ecssnapshot::ECSStateReplyV2>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ecssnapshot::ECSStateRequestLatestStream* request) { return this->GetStateLatestStreamV2(context, request); }));
    }
    ~WithCallbackMethod_GetStateLatestStreamV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatestStreamV2(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStream* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReplyV2>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::ecssnapshot::ECSStateReplyV2>* GetStateLatestStreamV2(
      ::grpc::CallbackServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStream* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetStateLatestStreamPruned : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetStateLatestStreamPruned() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::ecssnapshot::ECSStateRequestLatestStreamPruned, ::ecssnapshot::ECSStateReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned* request) { return this->GetStateLatestStreamPruned(context, request); }));
    }
    ~WithCallbackMethod_GetStateLatestStreamPruned() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatestStreamPruned(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStreamPruned* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::ecssnapshot::ECSStateReply>* GetStateLatestStreamPruned(
      ::grpc::CallbackServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStreamPruned* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetStateLatestStreamPrunedV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetStateLatestStreamPrunedV2() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackServerStreamingHandler< ::ecssnapshot::ECSStateRequestLatestStreamPruned, ::ecssnapshot::ECSStateReplyV2>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ecssnapshot::ECSStateRequestLatestStreamPruned* request) { return this->GetStateLatestStreamPrunedV2(context, request); }));
    }
    ~WithCallbackMethod_GetStateLatestStreamPrunedV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatestStreamPrunedV2(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStreamPruned* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReplyV2>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::ecssnapshot::ECSStateReplyV2>* GetStateLatestStreamPrunedV2(
      ::grpc::CallbackServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStreamPruned* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetStateBlockLatest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetStateBlockLatest() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::ecssnapshot::ECSStateBlockRequestLatest, ::ecssnapshot::ECSStateBlockReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ecssnapshot::ECSStateBlockRequestLatest* request, ::ecssnapshot::ECSStateBlockReply* response) { return this->GetStateBlockLatest(context, request, response); }));}
    void SetMessageAllocatorFor_GetStateBlockLatest(
        ::grpc::MessageAllocator< ::ecssnapshot::ECSStateBlockRequestLatest, ::ecssnapshot::ECSStateBlockReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ecssnapshot::ECSStateBlockRequestLatest, ::ecssnapshot::ECSStateBlockReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetStateBlockLatest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateBlockLatest(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateBlockRequestLatest* /*request*/, ::ecssnapshot::ECSStateBlockReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetStateBlockLatest(
      ::grpc::CallbackServerContext* /*context*/, const ::ecssnapshot::ECSStateBlockRequestLatest* /*request*/, ::ecssnapshot::ECSStateBlockReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetStateAtBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetStateAtBlock() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::ecssnapshot::ECSStateRequestAtBlock, ::ecssnapshot::ECSStateReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ecssnapshot::ECSStateRequestAtBlock* request, ::ecssnapshot::ECSStateReply* response) { return this->GetStateAtBlock(context, request, response); }));}
    void SetMessageAllocatorFor_GetStateAtBlock(
        ::grpc::MessageAllocator< ::ecssnapshot::ECSStateRequestAtBlock, ::ecssnapshot::ECSStateReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ecssnapshot::ECSStateRequestAtBlock, ::ecssnapshot::ECSStateReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetStateAtBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateAtBlock(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestAtBlock* /*request*/, ::ecssnapshot::ECSStateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetStateAtBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestAtBlock* /*request*/, ::ecssnapshot::ECSStateReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetWorlds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetWorlds() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::ecssnapshot::WorldsRequest, ::ecssnapshot::Worlds>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ecssnapshot::WorldsRequest* request, ::ecssnapshot::Worlds* response) { return this->GetWorlds(context, request, response); }));}
    void SetMessageAllocatorFor_GetWorlds(
        ::grpc::MessageAllocator< ::ecssnapshot::WorldsRequest, ::ecssnapshot::Worlds>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ecssnapshot::WorldsRequest, ::ecssnapshot::Worlds>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetWorlds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorlds(::grpc::ServerContext* /*context*/, const ::ecssnapshot::WorldsRequest* /*request*/, ::ecssnapshot::Worlds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetWorlds(
      ::grpc::CallbackServerContext* /*context*/, const ::ecssnapshot::WorldsRequest* /*request*/, ::ecssnapshot::Worlds* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_GetStateLatest<WithCallbackMethod_GetStateLatestStream<WithCallbackMethod_GetStateLatestStreamV2<WithCallbackMethod_GetStateLatestStreamPruned<WithCallbackMethod_GetStateLatestStreamPrunedV2<WithCallbackMethod_GetStateBlockLatest<WithCallbackMethod_GetStateAtBlock<WithCallbackMethod_GetWorlds<Service > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetStateLatest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetStateLatest() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetStateLatest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatest(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatest* /*request*/, ::ecssnapshot::ECSStateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetStateLatestStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetStateLatestStream() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetStateLatestStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatestStream(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStream* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetStateLatestStreamV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetStateLatestStreamV2() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetStateLatestStreamV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatestStreamV2(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStream* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReplyV2>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetStateLatestStreamPruned : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetStateLatestStreamPruned() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetStateLatestStreamPruned() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatestStreamPruned(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStreamPruned* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetStateLatestStreamPrunedV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetStateLatestStreamPrunedV2() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetStateLatestStreamPrunedV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatestStreamPrunedV2(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStreamPruned* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReplyV2>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetStateBlockLatest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetStateBlockLatest() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetStateBlockLatest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateBlockLatest(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateBlockRequestLatest* /*request*/, ::ecssnapshot::ECSStateBlockReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetStateAtBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetStateAtBlock() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetStateAtBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateAtBlock(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestAtBlock* /*request*/, ::ecssnapshot::ECSStateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetWorlds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetWorlds() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetWorlds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorlds(::grpc::ServerContext* /*context*/, const ::ecssnapshot::WorldsRequest* /*request*/, ::ecssnapshot::Worlds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetStateLatest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetStateLatest() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetStateLatest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatest(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatest* /*request*/, ::ecssnapshot::ECSStateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStateLatest(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetStateLatestStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetStateLatestStream() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetStateLatestStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatestStream(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStream* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStateLatestStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetStateLatestStreamV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetStateLatestStreamV2() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetStateLatestStreamV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatestStreamV2(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStream* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReplyV2>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStateLatestStreamV2(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetStateLatestStreamPruned : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetStateLatestStreamPruned() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetStateLatestStreamPruned() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatestStreamPruned(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStreamPruned* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStateLatestStreamPruned(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetStateLatestStreamPrunedV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetStateLatestStreamPrunedV2() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetStateLatestStreamPrunedV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatestStreamPrunedV2(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStreamPruned* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReplyV2>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStateLatestStreamPrunedV2(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(4, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetStateBlockLatest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetStateBlockLatest() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetStateBlockLatest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateBlockLatest(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateBlockRequestLatest* /*request*/, ::ecssnapshot::ECSStateBlockReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStateBlockLatest(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetStateAtBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetStateAtBlock() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetStateAtBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateAtBlock(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestAtBlock* /*request*/, ::ecssnapshot::ECSStateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStateAtBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetWorlds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetWorlds() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetWorlds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorlds(::grpc::ServerContext* /*context*/, const ::ecssnapshot::WorldsRequest* /*request*/, ::ecssnapshot::Worlds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWorlds(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetStateLatest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetStateLatest() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetStateLatest(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetStateLatest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatest(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatest* /*request*/, ::ecssnapshot::ECSStateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetStateLatest(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetStateLatestStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetStateLatestStream() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->GetStateLatestStream(context, request); }));
    }
    ~WithRawCallbackMethod_GetStateLatestStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatestStream(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStream* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GetStateLatestStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetStateLatestStreamV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetStateLatestStreamV2() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->GetStateLatestStreamV2(context, request); }));
    }
    ~WithRawCallbackMethod_GetStateLatestStreamV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatestStreamV2(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStream* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReplyV2>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GetStateLatestStreamV2(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetStateLatestStreamPruned : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetStateLatestStreamPruned() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->GetStateLatestStreamPruned(context, request); }));
    }
    ~WithRawCallbackMethod_GetStateLatestStreamPruned() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatestStreamPruned(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStreamPruned* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GetStateLatestStreamPruned(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetStateLatestStreamPrunedV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetStateLatestStreamPrunedV2() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->GetStateLatestStreamPrunedV2(context, request); }));
    }
    ~WithRawCallbackMethod_GetStateLatestStreamPrunedV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateLatestStreamPrunedV2(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStreamPruned* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReplyV2>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GetStateLatestStreamPrunedV2(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetStateBlockLatest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetStateBlockLatest() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetStateBlockLatest(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetStateBlockLatest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateBlockLatest(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateBlockRequestLatest* /*request*/, ::ecssnapshot::ECSStateBlockReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetStateBlockLatest(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetStateAtBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetStateAtBlock() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetStateAtBlock(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetStateAtBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStateAtBlock(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestAtBlock* /*request*/, ::ecssnapshot::ECSStateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetStateAtBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetWorlds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetWorlds() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetWorlds(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetWorlds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorlds(::grpc::ServerContext* /*context*/, const ::ecssnapshot::WorldsRequest* /*request*/, ::ecssnapshot::Worlds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetWorlds(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetStateLatest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetStateLatest() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ecssnapshot::ECSStateRequestLatest, ::ecssnapshot::ECSStateReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ecssnapshot::ECSStateRequestLatest, ::ecssnapshot::ECSStateReply>* streamer) {
                       return this->StreamedGetStateLatest(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetStateLatest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetStateLatest(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatest* /*request*/, ::ecssnapshot::ECSStateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetStateLatest(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ecssnapshot::ECSStateRequestLatest,::ecssnapshot::ECSStateReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetStateBlockLatest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetStateBlockLatest() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ecssnapshot::ECSStateBlockRequestLatest, ::ecssnapshot::ECSStateBlockReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ecssnapshot::ECSStateBlockRequestLatest, ::ecssnapshot::ECSStateBlockReply>* streamer) {
                       return this->StreamedGetStateBlockLatest(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetStateBlockLatest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetStateBlockLatest(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateBlockRequestLatest* /*request*/, ::ecssnapshot::ECSStateBlockReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetStateBlockLatest(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ecssnapshot::ECSStateBlockRequestLatest,::ecssnapshot::ECSStateBlockReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetStateAtBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetStateAtBlock() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ecssnapshot::ECSStateRequestAtBlock, ::ecssnapshot::ECSStateReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ecssnapshot::ECSStateRequestAtBlock, ::ecssnapshot::ECSStateReply>* streamer) {
                       return this->StreamedGetStateAtBlock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetStateAtBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetStateAtBlock(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestAtBlock* /*request*/, ::ecssnapshot::ECSStateReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetStateAtBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ecssnapshot::ECSStateRequestAtBlock,::ecssnapshot::ECSStateReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetWorlds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetWorlds() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ecssnapshot::WorldsRequest, ::ecssnapshot::Worlds>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ecssnapshot::WorldsRequest, ::ecssnapshot::Worlds>* streamer) {
                       return this->StreamedGetWorlds(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetWorlds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetWorlds(::grpc::ServerContext* /*context*/, const ::ecssnapshot::WorldsRequest* /*request*/, ::ecssnapshot::Worlds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetWorlds(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ecssnapshot::WorldsRequest,::ecssnapshot::Worlds>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetStateLatest<WithStreamedUnaryMethod_GetStateBlockLatest<WithStreamedUnaryMethod_GetStateAtBlock<WithStreamedUnaryMethod_GetWorlds<Service > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_GetStateLatestStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GetStateLatestStream() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::ecssnapshot::ECSStateRequestLatestStream, ::ecssnapshot::ECSStateReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::ecssnapshot::ECSStateRequestLatestStream, ::ecssnapshot::ECSStateReply>* streamer) {
                       return this->StreamedGetStateLatestStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GetStateLatestStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetStateLatestStream(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStream* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetStateLatestStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::ecssnapshot::ECSStateRequestLatestStream,::ecssnapshot::ECSStateReply>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_GetStateLatestStreamV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GetStateLatestStreamV2() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::ecssnapshot::ECSStateRequestLatestStream, ::ecssnapshot::ECSStateReplyV2>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::ecssnapshot::ECSStateRequestLatestStream, ::ecssnapshot::ECSStateReplyV2>* streamer) {
                       return this->StreamedGetStateLatestStreamV2(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GetStateLatestStreamV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetStateLatestStreamV2(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStream* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReplyV2>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetStateLatestStreamV2(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::ecssnapshot::ECSStateRequestLatestStream,::ecssnapshot::ECSStateReplyV2>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_GetStateLatestStreamPruned : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GetStateLatestStreamPruned() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::ecssnapshot::ECSStateRequestLatestStreamPruned, ::ecssnapshot::ECSStateReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::ecssnapshot::ECSStateRequestLatestStreamPruned, ::ecssnapshot::ECSStateReply>* streamer) {
                       return this->StreamedGetStateLatestStreamPruned(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GetStateLatestStreamPruned() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetStateLatestStreamPruned(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStreamPruned* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetStateLatestStreamPruned(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::ecssnapshot::ECSStateRequestLatestStreamPruned,::ecssnapshot::ECSStateReply>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_GetStateLatestStreamPrunedV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GetStateLatestStreamPrunedV2() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::ecssnapshot::ECSStateRequestLatestStreamPruned, ::ecssnapshot::ECSStateReplyV2>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::ecssnapshot::ECSStateRequestLatestStreamPruned, ::ecssnapshot::ECSStateReplyV2>* streamer) {
                       return this->StreamedGetStateLatestStreamPrunedV2(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GetStateLatestStreamPrunedV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetStateLatestStreamPrunedV2(::grpc::ServerContext* /*context*/, const ::ecssnapshot::ECSStateRequestLatestStreamPruned* /*request*/, ::grpc::ServerWriter< ::ecssnapshot::ECSStateReplyV2>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetStateLatestStreamPrunedV2(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::ecssnapshot::ECSStateRequestLatestStreamPruned,::ecssnapshot::ECSStateReplyV2>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_GetStateLatestStream<WithSplitStreamingMethod_GetStateLatestStreamV2<WithSplitStreamingMethod_GetStateLatestStreamPruned<WithSplitStreamingMethod_GetStateLatestStreamPrunedV2<Service > > > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetStateLatest<WithSplitStreamingMethod_GetStateLatestStream<WithSplitStreamingMethod_GetStateLatestStreamV2<WithSplitStreamingMethod_GetStateLatestStreamPruned<WithSplitStreamingMethod_GetStateLatestStreamPrunedV2<WithStreamedUnaryMethod_GetStateBlockLatest<WithStreamedUnaryMethod_GetStateAtBlock<WithStreamedUnaryMethod_GetWorlds<Service > > > > > > > > StreamedService;
};

}  // namespace ecssnapshot


#endif  // GRPC_ecs_5fsnapshot_2eproto__INCLUDED
