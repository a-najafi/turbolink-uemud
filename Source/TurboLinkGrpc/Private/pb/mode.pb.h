#if defined(_MSC_VER)
  #pragma warning (disable:4946) // reinterpret_cast used between related classes: 'class1' and 'class2'
  #pragma warning (disable:4800) // 'type' : forcing value to bool 'true' or 'false' (performance warning)
#endif
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mode.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mode_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mode_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mode_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mode_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[25]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mode_2eproto;
namespace mode {
class CreateRequest;
struct CreateRequestDefaultTypeInternal;
extern CreateRequestDefaultTypeInternal _CreateRequest_default_instance_;
class DeleteRequest;
struct DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class Field;
struct FieldDefaultTypeInternal;
extern FieldDefaultTypeInternal _Field_default_instance_;
class FieldPair;
struct FieldPairDefaultTypeInternal;
extern FieldPairDefaultTypeInternal _FieldPair_default_instance_;
class Filter;
struct FilterDefaultTypeInternal;
extern FilterDefaultTypeInternal _Filter_default_instance_;
class FindAllRequest;
struct FindAllRequestDefaultTypeInternal;
extern FindAllRequestDefaultTypeInternal _FindAllRequest_default_instance_;
class FindRequest;
struct FindRequestDefaultTypeInternal;
extern FindRequestDefaultTypeInternal _FindRequest_default_instance_;
class FindRequestOptions;
struct FindRequestOptionsDefaultTypeInternal;
extern FindRequestOptionsDefaultTypeInternal _FindRequestOptions_default_instance_;
class GenericTable;
struct GenericTableDefaultTypeInternal;
extern GenericTableDefaultTypeInternal _GenericTable_default_instance_;
class InsertRequest;
struct InsertRequestDefaultTypeInternal;
extern InsertRequestDefaultTypeInternal _InsertRequest_default_instance_;
class InsertRequest_RowEntry_DoNotUse;
struct InsertRequest_RowEntry_DoNotUseDefaultTypeInternal;
extern InsertRequest_RowEntry_DoNotUseDefaultTypeInternal _InsertRequest_RowEntry_DoNotUse_default_instance_;
class JoinRequest;
struct JoinRequestDefaultTypeInternal;
extern JoinRequestDefaultTypeInternal _JoinRequest_default_instance_;
class Namespace;
struct NamespaceDefaultTypeInternal;
extern NamespaceDefaultTypeInternal _Namespace_default_instance_;
class ProjectedField;
struct ProjectedFieldDefaultTypeInternal;
extern ProjectedFieldDefaultTypeInternal _ProjectedField_default_instance_;
class QueryLayerResponse;
struct QueryLayerResponseDefaultTypeInternal;
extern QueryLayerResponseDefaultTypeInternal _QueryLayerResponse_default_instance_;
class QueryLayerResponse_TablesEntry_DoNotUse;
struct QueryLayerResponse_TablesEntry_DoNotUseDefaultTypeInternal;
extern QueryLayerResponse_TablesEntry_DoNotUseDefaultTypeInternal _QueryLayerResponse_TablesEntry_DoNotUse_default_instance_;
class QueryLayerStateResponse;
struct QueryLayerStateResponseDefaultTypeInternal;
extern QueryLayerStateResponseDefaultTypeInternal _QueryLayerStateResponse_default_instance_;
class QueryLayerStateResponse_ChainTablesEntry_DoNotUse;
struct QueryLayerStateResponse_ChainTablesEntry_DoNotUseDefaultTypeInternal;
extern QueryLayerStateResponse_ChainTablesEntry_DoNotUseDefaultTypeInternal _QueryLayerStateResponse_ChainTablesEntry_DoNotUse_default_instance_;
class QueryLayerStateResponse_WorldTablesEntry_DoNotUse;
struct QueryLayerStateResponse_WorldTablesEntry_DoNotUseDefaultTypeInternal;
extern QueryLayerStateResponse_WorldTablesEntry_DoNotUseDefaultTypeInternal _QueryLayerStateResponse_WorldTablesEntry_DoNotUse_default_instance_;
class QueryLayerStateStreamResponse;
struct QueryLayerStateStreamResponseDefaultTypeInternal;
extern QueryLayerStateStreamResponseDefaultTypeInternal _QueryLayerStateStreamResponse_default_instance_;
class Row;
struct RowDefaultTypeInternal;
extern RowDefaultTypeInternal _Row_default_instance_;
class Single__StateRequest;
struct Single__StateRequestDefaultTypeInternal;
extern Single__StateRequestDefaultTypeInternal _Single__StateRequest_default_instance_;
class StateRequest;
struct StateRequestDefaultTypeInternal;
extern StateRequestDefaultTypeInternal _StateRequest_default_instance_;
class UpdateRequest;
struct UpdateRequestDefaultTypeInternal;
extern UpdateRequestDefaultTypeInternal _UpdateRequest_default_instance_;
class UpdateRequest_RowEntry_DoNotUse;
struct UpdateRequest_RowEntry_DoNotUseDefaultTypeInternal;
extern UpdateRequest_RowEntry_DoNotUseDefaultTypeInternal _UpdateRequest_RowEntry_DoNotUse_default_instance_;
}  // namespace mode
PROTOBUF_NAMESPACE_OPEN
template<> ::mode::CreateRequest* Arena::CreateMaybeMessage<::mode::CreateRequest>(Arena*);
template<> ::mode::DeleteRequest* Arena::CreateMaybeMessage<::mode::DeleteRequest>(Arena*);
template<> ::mode::Field* Arena::CreateMaybeMessage<::mode::Field>(Arena*);
template<> ::mode::FieldPair* Arena::CreateMaybeMessage<::mode::FieldPair>(Arena*);
template<> ::mode::Filter* Arena::CreateMaybeMessage<::mode::Filter>(Arena*);
template<> ::mode::FindAllRequest* Arena::CreateMaybeMessage<::mode::FindAllRequest>(Arena*);
template<> ::mode::FindRequest* Arena::CreateMaybeMessage<::mode::FindRequest>(Arena*);
template<> ::mode::FindRequestOptions* Arena::CreateMaybeMessage<::mode::FindRequestOptions>(Arena*);
template<> ::mode::GenericTable* Arena::CreateMaybeMessage<::mode::GenericTable>(Arena*);
template<> ::mode::InsertRequest* Arena::CreateMaybeMessage<::mode::InsertRequest>(Arena*);
template<> ::mode::InsertRequest_RowEntry_DoNotUse* Arena::CreateMaybeMessage<::mode::InsertRequest_RowEntry_DoNotUse>(Arena*);
template<> ::mode::JoinRequest* Arena::CreateMaybeMessage<::mode::JoinRequest>(Arena*);
template<> ::mode::Namespace* Arena::CreateMaybeMessage<::mode::Namespace>(Arena*);
template<> ::mode::ProjectedField* Arena::CreateMaybeMessage<::mode::ProjectedField>(Arena*);
template<> ::mode::QueryLayerResponse* Arena::CreateMaybeMessage<::mode::QueryLayerResponse>(Arena*);
template<> ::mode::QueryLayerResponse_TablesEntry_DoNotUse* Arena::CreateMaybeMessage<::mode::QueryLayerResponse_TablesEntry_DoNotUse>(Arena*);
template<> ::mode::QueryLayerStateResponse* Arena::CreateMaybeMessage<::mode::QueryLayerStateResponse>(Arena*);
template<> ::mode::QueryLayerStateResponse_ChainTablesEntry_DoNotUse* Arena::CreateMaybeMessage<::mode::QueryLayerStateResponse_ChainTablesEntry_DoNotUse>(Arena*);
template<> ::mode::QueryLayerStateResponse_WorldTablesEntry_DoNotUse* Arena::CreateMaybeMessage<::mode::QueryLayerStateResponse_WorldTablesEntry_DoNotUse>(Arena*);
template<> ::mode::QueryLayerStateStreamResponse* Arena::CreateMaybeMessage<::mode::QueryLayerStateStreamResponse>(Arena*);
template<> ::mode::Row* Arena::CreateMaybeMessage<::mode::Row>(Arena*);
template<> ::mode::Single__StateRequest* Arena::CreateMaybeMessage<::mode::Single__StateRequest>(Arena*);
template<> ::mode::StateRequest* Arena::CreateMaybeMessage<::mode::StateRequest>(Arena*);
template<> ::mode::UpdateRequest* Arena::CreateMaybeMessage<::mode::UpdateRequest>(Arena*);
template<> ::mode::UpdateRequest_RowEntry_DoNotUse* Arena::CreateMaybeMessage<::mode::UpdateRequest_RowEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mode {

// ===================================================================

class Row final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mode.Row) */ {
 public:
  inline Row() : Row(nullptr) {}
  ~Row() override;
  explicit constexpr Row(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Row(const Row& from);
  Row(Row&& from) noexcept
    : Row() {
    *this = ::std::move(from);
  }

  inline Row& operator=(const Row& from) {
    CopyFrom(from);
    return *this;
  }
  inline Row& operator=(Row&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Row& default_instance() {
    return *internal_default_instance();
  }
  static inline const Row* internal_default_instance() {
    return reinterpret_cast<const Row*>(
               &_Row_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Row& a, Row& b) {
    a.Swap(&b);
  }
  inline void Swap(Row* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Row* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Row* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Row>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Row& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Row& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Row* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mode.Row";
  }
  protected:
  explicit Row(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 2,
  };
  // repeated bytes values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  const std::string& values(int index) const;
  std::string* mutable_values(int index);
  void set_values(int index, const std::string& value);
  void set_values(int index, std::string&& value);
  void set_values(int index, const char* value);
  void set_values(int index, const void* value, size_t size);
  std::string* add_values();
  void add_values(const std::string& value);
  void add_values(std::string&& value);
  void add_values(const char* value);
  void add_values(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_values();
  private:
  const std::string& _internal_values(int index) const;
  std::string* _internal_add_values();
  public:

  // @@protoc_insertion_point(class_scope:mode.Row)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mode_2eproto;
};
// -------------------------------------------------------------------

class GenericTable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mode.GenericTable) */ {
 public:
  inline GenericTable() : GenericTable(nullptr) {}
  ~GenericTable() override;
  explicit constexpr GenericTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenericTable(const GenericTable& from);
  GenericTable(GenericTable&& from) noexcept
    : GenericTable() {
    *this = ::std::move(from);
  }

  inline GenericTable& operator=(const GenericTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericTable& operator=(GenericTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenericTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenericTable* internal_default_instance() {
    return reinterpret_cast<const GenericTable*>(
               &_GenericTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GenericTable& a, GenericTable& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericTable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenericTable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenericTable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GenericTable& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenericTable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mode.GenericTable";
  }
  protected:
  explicit GenericTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColsFieldNumber = 1,
    kRowsFieldNumber = 2,
    kTypesFieldNumber = 3,
  };
  // repeated string cols = 1;
  int cols_size() const;
  private:
  int _internal_cols_size() const;
  public:
  void clear_cols();
  const std::string& cols(int index) const;
  std::string* mutable_cols(int index);
  void set_cols(int index, const std::string& value);
  void set_cols(int index, std::string&& value);
  void set_cols(int index, const char* value);
  void set_cols(int index, const char* value, size_t size);
  std::string* add_cols();
  void add_cols(const std::string& value);
  void add_cols(std::string&& value);
  void add_cols(const char* value);
  void add_cols(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& cols() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_cols();
  private:
  const std::string& _internal_cols(int index) const;
  std::string* _internal_add_cols();
  public:

  // repeated .mode.Row rows = 2;
  int rows_size() const;
  private:
  int _internal_rows_size() const;
  public:
  void clear_rows();
  ::mode::Row* mutable_rows(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Row >*
      mutable_rows();
  private:
  const ::mode::Row& _internal_rows(int index) const;
  ::mode::Row* _internal_add_rows();
  public:
  const ::mode::Row& rows(int index) const;
  ::mode::Row* add_rows();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Row >&
      rows() const;

  // repeated string types = 3;
  int types_size() const;
  private:
  int _internal_types_size() const;
  public:
  void clear_types();
  const std::string& types(int index) const;
  std::string* mutable_types(int index);
  void set_types(int index, const std::string& value);
  void set_types(int index, std::string&& value);
  void set_types(int index, const char* value);
  void set_types(int index, const char* value, size_t size);
  std::string* add_types();
  void add_types(const std::string& value);
  void add_types(std::string&& value);
  void add_types(const char* value);
  void add_types(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_types();
  private:
  const std::string& _internal_types(int index) const;
  std::string* _internal_add_types();
  public:

  // @@protoc_insertion_point(class_scope:mode.GenericTable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> cols_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Row > rows_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> types_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mode_2eproto;
};
// -------------------------------------------------------------------

class QueryLayerResponse_TablesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<QueryLayerResponse_TablesEntry_DoNotUse, 
    std::string, ::mode::GenericTable,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<QueryLayerResponse_TablesEntry_DoNotUse, 
    std::string, ::mode::GenericTable,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  QueryLayerResponse_TablesEntry_DoNotUse();
  explicit constexpr QueryLayerResponse_TablesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit QueryLayerResponse_TablesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const QueryLayerResponse_TablesEntry_DoNotUse& other);
  static const QueryLayerResponse_TablesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const QueryLayerResponse_TablesEntry_DoNotUse*>(&_QueryLayerResponse_TablesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mode.QueryLayerResponse.TablesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class QueryLayerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mode.QueryLayerResponse) */ {
 public:
  inline QueryLayerResponse() : QueryLayerResponse(nullptr) {}
  ~QueryLayerResponse() override;
  explicit constexpr QueryLayerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryLayerResponse(const QueryLayerResponse& from);
  QueryLayerResponse(QueryLayerResponse&& from) noexcept
    : QueryLayerResponse() {
    *this = ::std::move(from);
  }

  inline QueryLayerResponse& operator=(const QueryLayerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryLayerResponse& operator=(QueryLayerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryLayerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryLayerResponse* internal_default_instance() {
    return reinterpret_cast<const QueryLayerResponse*>(
               &_QueryLayerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(QueryLayerResponse& a, QueryLayerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryLayerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryLayerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryLayerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryLayerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryLayerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryLayerResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryLayerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mode.QueryLayerResponse";
  }
  protected:
  explicit QueryLayerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTablesFieldNumber = 1,
  };
  // map<string, .mode.GenericTable> tables = 1;
  int tables_size() const;
  private:
  int _internal_tables_size() const;
  public:
  void clear_tables();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >&
      _internal_tables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >*
      _internal_mutable_tables();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >&
      tables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >*
      mutable_tables();

  // @@protoc_insertion_point(class_scope:mode.QueryLayerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      QueryLayerResponse_TablesEntry_DoNotUse,
      std::string, ::mode::GenericTable,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> tables_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mode_2eproto;
};
// -------------------------------------------------------------------

class QueryLayerStateResponse_ChainTablesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<QueryLayerStateResponse_ChainTablesEntry_DoNotUse, 
    std::string, ::mode::GenericTable,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<QueryLayerStateResponse_ChainTablesEntry_DoNotUse, 
    std::string, ::mode::GenericTable,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  QueryLayerStateResponse_ChainTablesEntry_DoNotUse();
  explicit constexpr QueryLayerStateResponse_ChainTablesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit QueryLayerStateResponse_ChainTablesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const QueryLayerStateResponse_ChainTablesEntry_DoNotUse& other);
  static const QueryLayerStateResponse_ChainTablesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const QueryLayerStateResponse_ChainTablesEntry_DoNotUse*>(&_QueryLayerStateResponse_ChainTablesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mode.QueryLayerStateResponse.ChainTablesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class QueryLayerStateResponse_WorldTablesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<QueryLayerStateResponse_WorldTablesEntry_DoNotUse, 
    std::string, ::mode::GenericTable,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<QueryLayerStateResponse_WorldTablesEntry_DoNotUse, 
    std::string, ::mode::GenericTable,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  QueryLayerStateResponse_WorldTablesEntry_DoNotUse();
  explicit constexpr QueryLayerStateResponse_WorldTablesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit QueryLayerStateResponse_WorldTablesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const QueryLayerStateResponse_WorldTablesEntry_DoNotUse& other);
  static const QueryLayerStateResponse_WorldTablesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const QueryLayerStateResponse_WorldTablesEntry_DoNotUse*>(&_QueryLayerStateResponse_WorldTablesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mode.QueryLayerStateResponse.WorldTablesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class QueryLayerStateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mode.QueryLayerStateResponse) */ {
 public:
  inline QueryLayerStateResponse() : QueryLayerStateResponse(nullptr) {}
  ~QueryLayerStateResponse() override;
  explicit constexpr QueryLayerStateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryLayerStateResponse(const QueryLayerStateResponse& from);
  QueryLayerStateResponse(QueryLayerStateResponse&& from) noexcept
    : QueryLayerStateResponse() {
    *this = ::std::move(from);
  }

  inline QueryLayerStateResponse& operator=(const QueryLayerStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryLayerStateResponse& operator=(QueryLayerStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryLayerStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryLayerStateResponse* internal_default_instance() {
    return reinterpret_cast<const QueryLayerStateResponse*>(
               &_QueryLayerStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(QueryLayerStateResponse& a, QueryLayerStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryLayerStateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryLayerStateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryLayerStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryLayerStateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryLayerStateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryLayerStateResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryLayerStateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mode.QueryLayerStateResponse";
  }
  protected:
  explicit QueryLayerStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kChainTablesFieldNumber = 1,
    kWorldTablesFieldNumber = 2,
  };
  // map<string, .mode.GenericTable> chainTables = 1;
  int chaintables_size() const;
  private:
  int _internal_chaintables_size() const;
  public:
  void clear_chaintables();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >&
      _internal_chaintables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >*
      _internal_mutable_chaintables();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >&
      chaintables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >*
      mutable_chaintables();

  // map<string, .mode.GenericTable> worldTables = 2;
  int worldtables_size() const;
  private:
  int _internal_worldtables_size() const;
  public:
  void clear_worldtables();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >&
      _internal_worldtables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >*
      _internal_mutable_worldtables();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >&
      worldtables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >*
      mutable_worldtables();

  // @@protoc_insertion_point(class_scope:mode.QueryLayerStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      QueryLayerStateResponse_ChainTablesEntry_DoNotUse,
      std::string, ::mode::GenericTable,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> chaintables_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      QueryLayerStateResponse_WorldTablesEntry_DoNotUse,
      std::string, ::mode::GenericTable,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> worldtables_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mode_2eproto;
};
// -------------------------------------------------------------------

class QueryLayerStateStreamResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mode.QueryLayerStateStreamResponse) */ {
 public:
  inline QueryLayerStateStreamResponse() : QueryLayerStateStreamResponse(nullptr) {}
  ~QueryLayerStateStreamResponse() override;
  explicit constexpr QueryLayerStateStreamResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryLayerStateStreamResponse(const QueryLayerStateStreamResponse& from);
  QueryLayerStateStreamResponse(QueryLayerStateStreamResponse&& from) noexcept
    : QueryLayerStateStreamResponse() {
    *this = ::std::move(from);
  }

  inline QueryLayerStateStreamResponse& operator=(const QueryLayerStateStreamResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryLayerStateStreamResponse& operator=(QueryLayerStateStreamResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryLayerStateStreamResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryLayerStateStreamResponse* internal_default_instance() {
    return reinterpret_cast<const QueryLayerStateStreamResponse*>(
               &_QueryLayerStateStreamResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(QueryLayerStateStreamResponse& a, QueryLayerStateStreamResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryLayerStateStreamResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryLayerStateStreamResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryLayerStateStreamResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryLayerStateStreamResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryLayerStateStreamResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryLayerStateStreamResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryLayerStateStreamResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mode.QueryLayerStateStreamResponse";
  }
  protected:
  explicit QueryLayerStateStreamResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInsertedFieldNumber = 1,
    kUpdatedFieldNumber = 2,
    kDeletedFieldNumber = 3,
  };
  // .mode.QueryLayerStateResponse inserted = 1;
  bool has_inserted() const;
  private:
  bool _internal_has_inserted() const;
  public:
  void clear_inserted();
  const ::mode::QueryLayerStateResponse& inserted() const;
  PROTOBUF_NODISCARD ::mode::QueryLayerStateResponse* release_inserted();
  ::mode::QueryLayerStateResponse* mutable_inserted();
  void set_allocated_inserted(::mode::QueryLayerStateResponse* inserted);
  private:
  const ::mode::QueryLayerStateResponse& _internal_inserted() const;
  ::mode::QueryLayerStateResponse* _internal_mutable_inserted();
  public:
  void unsafe_arena_set_allocated_inserted(
      ::mode::QueryLayerStateResponse* inserted);
  ::mode::QueryLayerStateResponse* unsafe_arena_release_inserted();

  // .mode.QueryLayerStateResponse updated = 2;
  bool has_updated() const;
  private:
  bool _internal_has_updated() const;
  public:
  void clear_updated();
  const ::mode::QueryLayerStateResponse& updated() const;
  PROTOBUF_NODISCARD ::mode::QueryLayerStateResponse* release_updated();
  ::mode::QueryLayerStateResponse* mutable_updated();
  void set_allocated_updated(::mode::QueryLayerStateResponse* updated);
  private:
  const ::mode::QueryLayerStateResponse& _internal_updated() const;
  ::mode::QueryLayerStateResponse* _internal_mutable_updated();
  public:
  void unsafe_arena_set_allocated_updated(
      ::mode::QueryLayerStateResponse* updated);
  ::mode::QueryLayerStateResponse* unsafe_arena_release_updated();

  // .mode.QueryLayerStateResponse deleted = 3;
  bool has_deleted() const;
  private:
  bool _internal_has_deleted() const;
  public:
  void clear_deleted();
  const ::mode::QueryLayerStateResponse& deleted() const;
  PROTOBUF_NODISCARD ::mode::QueryLayerStateResponse* release_deleted();
  ::mode::QueryLayerStateResponse* mutable_deleted();
  void set_allocated_deleted(::mode::QueryLayerStateResponse* deleted);
  private:
  const ::mode::QueryLayerStateResponse& _internal_deleted() const;
  ::mode::QueryLayerStateResponse* _internal_mutable_deleted();
  public:
  void unsafe_arena_set_allocated_deleted(
      ::mode::QueryLayerStateResponse* deleted);
  ::mode::QueryLayerStateResponse* unsafe_arena_release_deleted();

  // @@protoc_insertion_point(class_scope:mode.QueryLayerStateStreamResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::mode::QueryLayerStateResponse* inserted_;
  ::mode::QueryLayerStateResponse* updated_;
  ::mode::QueryLayerStateResponse* deleted_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mode_2eproto;
};
// -------------------------------------------------------------------

class Namespace final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mode.Namespace) */ {
 public:
  inline Namespace() : Namespace(nullptr) {}
  ~Namespace() override;
  explicit constexpr Namespace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Namespace(const Namespace& from);
  Namespace(Namespace&& from) noexcept
    : Namespace() {
    *this = ::std::move(from);
  }

  inline Namespace& operator=(const Namespace& from) {
    CopyFrom(from);
    return *this;
  }
  inline Namespace& operator=(Namespace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Namespace& default_instance() {
    return *internal_default_instance();
  }
  static inline const Namespace* internal_default_instance() {
    return reinterpret_cast<const Namespace*>(
               &_Namespace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Namespace& a, Namespace& b) {
    a.Swap(&b);
  }
  inline void Swap(Namespace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Namespace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Namespace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Namespace>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Namespace& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Namespace& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Namespace* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mode.Namespace";
  }
  protected:
  explicit Namespace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChainIdFieldNumber = 1,
    kWorldAddressFieldNumber = 2,
  };
  // string chainId = 1;
  void clear_chainid();
  const std::string& chainid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chainid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chainid();
  PROTOBUF_NODISCARD std::string* release_chainid();
  void set_allocated_chainid(std::string* chainid);
  private:
  const std::string& _internal_chainid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chainid(const std::string& value);
  std::string* _internal_mutable_chainid();
  public:

  // string worldAddress = 2;
  void clear_worldaddress();
  const std::string& worldaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_worldaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_worldaddress();
  PROTOBUF_NODISCARD std::string* release_worldaddress();
  void set_allocated_worldaddress(std::string* worldaddress);
  private:
  const std::string& _internal_worldaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_worldaddress(const std::string& value);
  std::string* _internal_mutable_worldaddress();
  public:

  // @@protoc_insertion_point(class_scope:mode.Namespace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chainid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr worldaddress_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mode_2eproto;
};
// -------------------------------------------------------------------

class StateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mode.StateRequest) */ {
 public:
  inline StateRequest() : StateRequest(nullptr) {}
  ~StateRequest() override;
  explicit constexpr StateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StateRequest(const StateRequest& from);
  StateRequest(StateRequest&& from) noexcept
    : StateRequest() {
    *this = ::std::move(from);
  }

  inline StateRequest& operator=(const StateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateRequest& operator=(StateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StateRequest* internal_default_instance() {
    return reinterpret_cast<const StateRequest*>(
               &_StateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StateRequest& a, StateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mode.StateRequest";
  }
  protected:
  explicit StateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorldTablesFieldNumber = 2,
    kChainTablesFieldNumber = 3,
    kNamespaceFieldNumber = 1,
  };
  // repeated string worldTables = 2;
  int worldtables_size() const;
  private:
  int _internal_worldtables_size() const;
  public:
  void clear_worldtables();
  const std::string& worldtables(int index) const;
  std::string* mutable_worldtables(int index);
  void set_worldtables(int index, const std::string& value);
  void set_worldtables(int index, std::string&& value);
  void set_worldtables(int index, const char* value);
  void set_worldtables(int index, const char* value, size_t size);
  std::string* add_worldtables();
  void add_worldtables(const std::string& value);
  void add_worldtables(std::string&& value);
  void add_worldtables(const char* value);
  void add_worldtables(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& worldtables() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_worldtables();
  private:
  const std::string& _internal_worldtables(int index) const;
  std::string* _internal_add_worldtables();
  public:

  // repeated string chainTables = 3;
  int chaintables_size() const;
  private:
  int _internal_chaintables_size() const;
  public:
  void clear_chaintables();
  const std::string& chaintables(int index) const;
  std::string* mutable_chaintables(int index);
  void set_chaintables(int index, const std::string& value);
  void set_chaintables(int index, std::string&& value);
  void set_chaintables(int index, const char* value);
  void set_chaintables(int index, const char* value, size_t size);
  std::string* add_chaintables();
  void add_chaintables(const std::string& value);
  void add_chaintables(std::string&& value);
  void add_chaintables(const char* value);
  void add_chaintables(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& chaintables() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_chaintables();
  private:
  const std::string& _internal_chaintables(int index) const;
  std::string* _internal_add_chaintables();
  public:

  // .mode.Namespace namespace = 1;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const ::mode::Namespace& namespace_() const;
  PROTOBUF_NODISCARD ::mode::Namespace* release_namespace_();
  ::mode::Namespace* mutable_namespace_();
  void set_allocated_namespace_(::mode::Namespace* namespace_);
  private:
  const ::mode::Namespace& _internal_namespace_() const;
  ::mode::Namespace* _internal_mutable_namespace_();
  public:
  void unsafe_arena_set_allocated_namespace_(
      ::mode::Namespace* namespace_);
  ::mode::Namespace* unsafe_arena_release_namespace_();

  // @@protoc_insertion_point(class_scope:mode.StateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> worldtables_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> chaintables_;
  ::mode::Namespace* namespace__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mode_2eproto;
};
// -------------------------------------------------------------------

class Single__StateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mode.Single__StateRequest) */ {
 public:
  inline Single__StateRequest() : Single__StateRequest(nullptr) {}
  ~Single__StateRequest() override;
  explicit constexpr Single__StateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Single__StateRequest(const Single__StateRequest& from);
  Single__StateRequest(Single__StateRequest&& from) noexcept
    : Single__StateRequest() {
    *this = ::std::move(from);
  }

  inline Single__StateRequest& operator=(const Single__StateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline Single__StateRequest& operator=(Single__StateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Single__StateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const Single__StateRequest* internal_default_instance() {
    return reinterpret_cast<const Single__StateRequest*>(
               &_Single__StateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Single__StateRequest& a, Single__StateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(Single__StateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Single__StateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Single__StateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Single__StateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Single__StateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Single__StateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Single__StateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mode.Single__StateRequest";
  }
  protected:
  explicit Single__StateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 3,
    kProjectFieldNumber = 4,
    kTableFieldNumber = 2,
    kNamespaceFieldNumber = 1,
  };
  // repeated .mode.Filter filter = 3;
  int filter_size() const;
  private:
  int _internal_filter_size() const;
  public:
  void clear_filter();
  ::mode::Filter* mutable_filter(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Filter >*
      mutable_filter();
  private:
  const ::mode::Filter& _internal_filter(int index) const;
  ::mode::Filter* _internal_add_filter();
  public:
  const ::mode::Filter& filter(int index) const;
  ::mode::Filter* add_filter();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Filter >&
      filter() const;

  // repeated .mode.ProjectedField project = 4;
  int project_size() const;
  private:
  int _internal_project_size() const;
  public:
  void clear_project();
  ::mode::ProjectedField* mutable_project(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::ProjectedField >*
      mutable_project();
  private:
  const ::mode::ProjectedField& _internal_project(int index) const;
  ::mode::ProjectedField* _internal_add_project();
  public:
  const ::mode::ProjectedField& project(int index) const;
  ::mode::ProjectedField* add_project();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::ProjectedField >&
      project() const;

  // string table = 2;
  void clear_table();
  const std::string& table() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table();
  PROTOBUF_NODISCARD std::string* release_table();
  void set_allocated_table(std::string* table);
  private:
  const std::string& _internal_table() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table(const std::string& value);
  std::string* _internal_mutable_table();
  public:

  // .mode.Namespace namespace = 1;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const ::mode::Namespace& namespace_() const;
  PROTOBUF_NODISCARD ::mode::Namespace* release_namespace_();
  ::mode::Namespace* mutable_namespace_();
  void set_allocated_namespace_(::mode::Namespace* namespace_);
  private:
  const ::mode::Namespace& _internal_namespace_() const;
  ::mode::Namespace* _internal_mutable_namespace_();
  public:
  void unsafe_arena_set_allocated_namespace_(
      ::mode::Namespace* namespace_);
  ::mode::Namespace* unsafe_arena_release_namespace_();

  // @@protoc_insertion_point(class_scope:mode.Single__StateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Filter > filter_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::ProjectedField > project_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_;
  ::mode::Namespace* namespace__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mode_2eproto;
};
// -------------------------------------------------------------------

class FindRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mode.FindRequest) */ {
 public:
  inline FindRequest() : FindRequest(nullptr) {}
  ~FindRequest() override;
  explicit constexpr FindRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindRequest(const FindRequest& from);
  FindRequest(FindRequest&& from) noexcept
    : FindRequest() {
    *this = ::std::move(from);
  }

  inline FindRequest& operator=(const FindRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindRequest& operator=(FindRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FindRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindRequest* internal_default_instance() {
    return reinterpret_cast<const FindRequest*>(
               &_FindRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(FindRequest& a, FindRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FindRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FindRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FindRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FindRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FindRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mode.FindRequest";
  }
  protected:
  explicit FindRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 2,
    kProjectFieldNumber = 3,
    kFromFieldNumber = 1,
    kNamespaceFieldNumber = 4,
    kOptionsFieldNumber = 5,
  };
  // repeated .mode.Filter filter = 2;
  int filter_size() const;
  private:
  int _internal_filter_size() const;
  public:
  void clear_filter();
  ::mode::Filter* mutable_filter(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Filter >*
      mutable_filter();
  private:
  const ::mode::Filter& _internal_filter(int index) const;
  ::mode::Filter* _internal_add_filter();
  public:
  const ::mode::Filter& filter(int index) const;
  ::mode::Filter* add_filter();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Filter >&
      filter() const;

  // repeated .mode.ProjectedField project = 3;
  int project_size() const;
  private:
  int _internal_project_size() const;
  public:
  void clear_project();
  ::mode::ProjectedField* mutable_project(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::ProjectedField >*
      mutable_project();
  private:
  const ::mode::ProjectedField& _internal_project(int index) const;
  ::mode::ProjectedField* _internal_add_project();
  public:
  const ::mode::ProjectedField& project(int index) const;
  ::mode::ProjectedField* add_project();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::ProjectedField >&
      project() const;

  // string from = 1;
  void clear_from();
  const std::string& from() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from();
  PROTOBUF_NODISCARD std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // .mode.Namespace namespace = 4;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const ::mode::Namespace& namespace_() const;
  PROTOBUF_NODISCARD ::mode::Namespace* release_namespace_();
  ::mode::Namespace* mutable_namespace_();
  void set_allocated_namespace_(::mode::Namespace* namespace_);
  private:
  const ::mode::Namespace& _internal_namespace_() const;
  ::mode::Namespace* _internal_mutable_namespace_();
  public:
  void unsafe_arena_set_allocated_namespace_(
      ::mode::Namespace* namespace_);
  ::mode::Namespace* unsafe_arena_release_namespace_();

  // .mode.FindRequestOptions options = 5;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::mode::FindRequestOptions& options() const;
  PROTOBUF_NODISCARD ::mode::FindRequestOptions* release_options();
  ::mode::FindRequestOptions* mutable_options();
  void set_allocated_options(::mode::FindRequestOptions* options);
  private:
  const ::mode::FindRequestOptions& _internal_options() const;
  ::mode::FindRequestOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::mode::FindRequestOptions* options);
  ::mode::FindRequestOptions* unsafe_arena_release_options();

  // @@protoc_insertion_point(class_scope:mode.FindRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Filter > filter_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::ProjectedField > project_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
  ::mode::Namespace* namespace__;
  ::mode::FindRequestOptions* options_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mode_2eproto;
};
// -------------------------------------------------------------------

class FindAllRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mode.FindAllRequest) */ {
 public:
  inline FindAllRequest() : FindAllRequest(nullptr) {}
  ~FindAllRequest() override;
  explicit constexpr FindAllRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindAllRequest(const FindAllRequest& from);
  FindAllRequest(FindAllRequest&& from) noexcept
    : FindAllRequest() {
    *this = ::std::move(from);
  }

  inline FindAllRequest& operator=(const FindAllRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindAllRequest& operator=(FindAllRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FindAllRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindAllRequest* internal_default_instance() {
    return reinterpret_cast<const FindAllRequest*>(
               &_FindAllRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FindAllRequest& a, FindAllRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FindAllRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindAllRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FindAllRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FindAllRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FindAllRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FindAllRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindAllRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mode.FindAllRequest";
  }
  protected:
  explicit FindAllRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTablesFieldNumber = 1,
    kNamespaceFieldNumber = 2,
    kOptionsFieldNumber = 3,
  };
  // repeated string tables = 1;
  int tables_size() const;
  private:
  int _internal_tables_size() const;
  public:
  void clear_tables();
  const std::string& tables(int index) const;
  std::string* mutable_tables(int index);
  void set_tables(int index, const std::string& value);
  void set_tables(int index, std::string&& value);
  void set_tables(int index, const char* value);
  void set_tables(int index, const char* value, size_t size);
  std::string* add_tables();
  void add_tables(const std::string& value);
  void add_tables(std::string&& value);
  void add_tables(const char* value);
  void add_tables(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tables() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tables();
  private:
  const std::string& _internal_tables(int index) const;
  std::string* _internal_add_tables();
  public:

  // .mode.Namespace namespace = 2;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const ::mode::Namespace& namespace_() const;
  PROTOBUF_NODISCARD ::mode::Namespace* release_namespace_();
  ::mode::Namespace* mutable_namespace_();
  void set_allocated_namespace_(::mode::Namespace* namespace_);
  private:
  const ::mode::Namespace& _internal_namespace_() const;
  ::mode::Namespace* _internal_mutable_namespace_();
  public:
  void unsafe_arena_set_allocated_namespace_(
      ::mode::Namespace* namespace_);
  ::mode::Namespace* unsafe_arena_release_namespace_();

  // .mode.FindRequestOptions options = 3;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::mode::FindRequestOptions& options() const;
  PROTOBUF_NODISCARD ::mode::FindRequestOptions* release_options();
  ::mode::FindRequestOptions* mutable_options();
  void set_allocated_options(::mode::FindRequestOptions* options);
  private:
  const ::mode::FindRequestOptions& _internal_options() const;
  ::mode::FindRequestOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::mode::FindRequestOptions* options);
  ::mode::FindRequestOptions* unsafe_arena_release_options();

  // @@protoc_insertion_point(class_scope:mode.FindAllRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tables_;
  ::mode::Namespace* namespace__;
  ::mode::FindRequestOptions* options_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mode_2eproto;
};
// -------------------------------------------------------------------

class JoinRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mode.JoinRequest) */ {
 public:
  inline JoinRequest() : JoinRequest(nullptr) {}
  ~JoinRequest() override;
  explicit constexpr JoinRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinRequest(const JoinRequest& from);
  JoinRequest(JoinRequest&& from) noexcept
    : JoinRequest() {
    *this = ::std::move(from);
  }

  inline JoinRequest& operator=(const JoinRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinRequest& operator=(JoinRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinRequest* internal_default_instance() {
    return reinterpret_cast<const JoinRequest*>(
               &_JoinRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(JoinRequest& a, JoinRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JoinRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mode.JoinRequest";
  }
  protected:
  explicit JoinRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildrenFieldNumber = 2,
    kOnFieldNumber = 1,
    kNamespaceFieldNumber = 3,
  };
  // repeated .mode.FindRequest children = 2;
  int children_size() const;
  private:
  int _internal_children_size() const;
  public:
  void clear_children();
  ::mode::FindRequest* mutable_children(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::FindRequest >*
      mutable_children();
  private:
  const ::mode::FindRequest& _internal_children(int index) const;
  ::mode::FindRequest* _internal_add_children();
  public:
  const ::mode::FindRequest& children(int index) const;
  ::mode::FindRequest* add_children();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::FindRequest >&
      children() const;

  // .mode.FieldPair on = 1;
  bool has_on() const;
  private:
  bool _internal_has_on() const;
  public:
  void clear_on();
  const ::mode::FieldPair& on() const;
  PROTOBUF_NODISCARD ::mode::FieldPair* release_on();
  ::mode::FieldPair* mutable_on();
  void set_allocated_on(::mode::FieldPair* on);
  private:
  const ::mode::FieldPair& _internal_on() const;
  ::mode::FieldPair* _internal_mutable_on();
  public:
  void unsafe_arena_set_allocated_on(
      ::mode::FieldPair* on);
  ::mode::FieldPair* unsafe_arena_release_on();

  // .mode.Namespace namespace = 3;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const ::mode::Namespace& namespace_() const;
  PROTOBUF_NODISCARD ::mode::Namespace* release_namespace_();
  ::mode::Namespace* mutable_namespace_();
  void set_allocated_namespace_(::mode::Namespace* namespace_);
  private:
  const ::mode::Namespace& _internal_namespace_() const;
  ::mode::Namespace* _internal_mutable_namespace_();
  public:
  void unsafe_arena_set_allocated_namespace_(
      ::mode::Namespace* namespace_);
  ::mode::Namespace* unsafe_arena_release_namespace_();

  // @@protoc_insertion_point(class_scope:mode.JoinRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::FindRequest > children_;
  ::mode::FieldPair* on_;
  ::mode::Namespace* namespace__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mode_2eproto;
};
// -------------------------------------------------------------------

class DeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mode.DeleteRequest) */ {
 public:
  inline DeleteRequest() : DeleteRequest(nullptr) {}
  ~DeleteRequest() override;
  explicit constexpr DeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRequest(const DeleteRequest& from);
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mode.DeleteRequest";
  }
  protected:
  explicit DeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 2,
    kFromFieldNumber = 1,
  };
  // repeated .mode.Filter filter = 2;
  int filter_size() const;
  private:
  int _internal_filter_size() const;
  public:
  void clear_filter();
  ::mode::Filter* mutable_filter(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Filter >*
      mutable_filter();
  private:
  const ::mode::Filter& _internal_filter(int index) const;
  ::mode::Filter* _internal_add_filter();
  public:
  const ::mode::Filter& filter(int index) const;
  ::mode::Filter* add_filter();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Filter >&
      filter() const;

  // string from = 1;
  void clear_from();
  const std::string& from() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from();
  PROTOBUF_NODISCARD std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // @@protoc_insertion_point(class_scope:mode.DeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Filter > filter_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mode_2eproto;
};
// -------------------------------------------------------------------

class UpdateRequest_RowEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UpdateRequest_RowEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UpdateRequest_RowEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  UpdateRequest_RowEntry_DoNotUse();
  explicit constexpr UpdateRequest_RowEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit UpdateRequest_RowEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const UpdateRequest_RowEntry_DoNotUse& other);
  static const UpdateRequest_RowEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const UpdateRequest_RowEntry_DoNotUse*>(&_UpdateRequest_RowEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mode.UpdateRequest.RowEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mode.UpdateRequest.RowEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class UpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mode.UpdateRequest) */ {
 public:
  inline UpdateRequest() : UpdateRequest(nullptr) {}
  ~UpdateRequest() override;
  explicit constexpr UpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRequest(const UpdateRequest& from);
  UpdateRequest(UpdateRequest&& from) noexcept
    : UpdateRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRequest& operator=(const UpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRequest& operator=(UpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRequest*>(
               &_UpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UpdateRequest& a, UpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mode.UpdateRequest";
  }
  protected:
  explicit UpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 2,
    kRowFieldNumber = 3,
    kTargetFieldNumber = 1,
  };
  // repeated .mode.Filter filter = 2;
  int filter_size() const;
  private:
  int _internal_filter_size() const;
  public:
  void clear_filter();
  ::mode::Filter* mutable_filter(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Filter >*
      mutable_filter();
  private:
  const ::mode::Filter& _internal_filter(int index) const;
  ::mode::Filter* _internal_add_filter();
  public:
  const ::mode::Filter& filter(int index) const;
  ::mode::Filter* add_filter();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Filter >&
      filter() const;

  // map<string, string> row = 3;
  int row_size() const;
  private:
  int _internal_row_size() const;
  public:
  void clear_row();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_row() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_row();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      row() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_row();

  // string target = 1;
  void clear_target();
  const std::string& target() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* target);
  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(const std::string& value);
  std::string* _internal_mutable_target();
  public:

  // @@protoc_insertion_point(class_scope:mode.UpdateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Filter > filter_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      UpdateRequest_RowEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> row_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mode_2eproto;
};
// -------------------------------------------------------------------

class InsertRequest_RowEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InsertRequest_RowEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InsertRequest_RowEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  InsertRequest_RowEntry_DoNotUse();
  explicit constexpr InsertRequest_RowEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit InsertRequest_RowEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const InsertRequest_RowEntry_DoNotUse& other);
  static const InsertRequest_RowEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const InsertRequest_RowEntry_DoNotUse*>(&_InsertRequest_RowEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mode.InsertRequest.RowEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mode.InsertRequest.RowEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class InsertRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mode.InsertRequest) */ {
 public:
  inline InsertRequest() : InsertRequest(nullptr) {}
  ~InsertRequest() override;
  explicit constexpr InsertRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertRequest(const InsertRequest& from);
  InsertRequest(InsertRequest&& from) noexcept
    : InsertRequest() {
    *this = ::std::move(from);
  }

  inline InsertRequest& operator=(const InsertRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertRequest& operator=(InsertRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertRequest* internal_default_instance() {
    return reinterpret_cast<const InsertRequest*>(
               &_InsertRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(InsertRequest& a, InsertRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InsertRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mode.InsertRequest";
  }
  protected:
  explicit InsertRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kRowFieldNumber = 3,
    kIntoFieldNumber = 1,
  };
  // map<string, string> row = 3;
  int row_size() const;
  private:
  int _internal_row_size() const;
  public:
  void clear_row();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_row() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_row();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      row() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_row();

  // string into = 1;
  void clear_into();
  const std::string& into() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_into(ArgT0&& arg0, ArgT... args);
  std::string* mutable_into();
  PROTOBUF_NODISCARD std::string* release_into();
  void set_allocated_into(std::string* into);
  private:
  const std::string& _internal_into() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_into(const std::string& value);
  std::string* _internal_mutable_into();
  public:

  // @@protoc_insertion_point(class_scope:mode.InsertRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      InsertRequest_RowEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> row_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr into_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mode_2eproto;
};
// -------------------------------------------------------------------

class CreateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mode.CreateRequest) */ {
 public:
  inline CreateRequest() : CreateRequest(nullptr) {}
  ~CreateRequest() override;
  explicit constexpr CreateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRequest(const CreateRequest& from);
  CreateRequest(CreateRequest&& from) noexcept
    : CreateRequest() {
    *this = ::std::move(from);
  }

  inline CreateRequest& operator=(const CreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRequest& operator=(CreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRequest*>(
               &_CreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CreateRequest& a, CreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mode.CreateRequest";
  }
  protected:
  explicit CreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:mode.CreateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mode_2eproto;
};
// -------------------------------------------------------------------

class FindRequestOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mode.FindRequestOptions) */ {
 public:
  inline FindRequestOptions() : FindRequestOptions(nullptr) {}
  ~FindRequestOptions() override;
  explicit constexpr FindRequestOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindRequestOptions(const FindRequestOptions& from);
  FindRequestOptions(FindRequestOptions&& from) noexcept
    : FindRequestOptions() {
    *this = ::std::move(from);
  }

  inline FindRequestOptions& operator=(const FindRequestOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindRequestOptions& operator=(FindRequestOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FindRequestOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindRequestOptions* internal_default_instance() {
    return reinterpret_cast<const FindRequestOptions*>(
               &_FindRequestOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(FindRequestOptions& a, FindRequestOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(FindRequestOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindRequestOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FindRequestOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FindRequestOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FindRequestOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FindRequestOptions& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindRequestOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mode.FindRequestOptions";
  }
  protected:
  explicit FindRequestOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompressedFieldNumber = 1,
    kGroupFieldNumber = 2,
    kNegateFieldNumber = 3,
  };
  // bool compressed = 1;
  void clear_compressed();
  bool compressed() const;
  void set_compressed(bool value);
  private:
  bool _internal_compressed() const;
  void _internal_set_compressed(bool value);
  public:

  // bool group = 2;
  void clear_group();
  bool group() const;
  void set_group(bool value);
  private:
  bool _internal_group() const;
  void _internal_set_group(bool value);
  public:

  // bool negate = 3;
  void clear_negate();
  bool negate() const;
  void set_negate(bool value);
  private:
  bool _internal_negate() const;
  void _internal_set_negate(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mode.FindRequestOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool compressed_;
  bool group_;
  bool negate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mode_2eproto;
};
// -------------------------------------------------------------------

class Field final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mode.Field) */ {
 public:
  inline Field() : Field(nullptr) {}
  ~Field() override;
  explicit constexpr Field(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Field(const Field& from);
  Field(Field&& from) noexcept
    : Field() {
    *this = ::std::move(from);
  }

  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }
  inline Field& operator=(Field&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Field& default_instance() {
    return *internal_default_instance();
  }
  static inline const Field* internal_default_instance() {
    return reinterpret_cast<const Field*>(
               &_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Field& a, Field& b) {
    a.Swap(&b);
  }
  inline void Swap(Field* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Field* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Field* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Field>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Field& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Field& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Field* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mode.Field";
  }
  protected:
  explicit Field(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableNameFieldNumber = 1,
    kTableFieldFieldNumber = 2,
  };
  // string table_name = 1;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // string table_field = 2;
  void clear_table_field();
  const std::string& table_field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_field();
  PROTOBUF_NODISCARD std::string* release_table_field();
  void set_allocated_table_field(std::string* table_field);
  private:
  const std::string& _internal_table_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_field(const std::string& value);
  std::string* _internal_mutable_table_field();
  public:

  // @@protoc_insertion_point(class_scope:mode.Field)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_field_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mode_2eproto;
};
// -------------------------------------------------------------------

class FieldPair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mode.FieldPair) */ {
 public:
  inline FieldPair() : FieldPair(nullptr) {}
  ~FieldPair() override;
  explicit constexpr FieldPair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FieldPair(const FieldPair& from);
  FieldPair(FieldPair&& from) noexcept
    : FieldPair() {
    *this = ::std::move(from);
  }

  inline FieldPair& operator=(const FieldPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldPair& operator=(FieldPair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldPair& default_instance() {
    return *internal_default_instance();
  }
  static inline const FieldPair* internal_default_instance() {
    return reinterpret_cast<const FieldPair*>(
               &_FieldPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(FieldPair& a, FieldPair& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldPair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldPair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FieldPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FieldPair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FieldPair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FieldPair& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldPair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mode.FieldPair";
  }
  protected:
  explicit FieldPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kField1FieldNumber = 1,
    kField2FieldNumber = 2,
  };
  // .mode.Field field1 = 1;
  bool has_field1() const;
  private:
  bool _internal_has_field1() const;
  public:
  void clear_field1();
  const ::mode::Field& field1() const;
  PROTOBUF_NODISCARD ::mode::Field* release_field1();
  ::mode::Field* mutable_field1();
  void set_allocated_field1(::mode::Field* field1);
  private:
  const ::mode::Field& _internal_field1() const;
  ::mode::Field* _internal_mutable_field1();
  public:
  void unsafe_arena_set_allocated_field1(
      ::mode::Field* field1);
  ::mode::Field* unsafe_arena_release_field1();

  // .mode.Field field2 = 2;
  bool has_field2() const;
  private:
  bool _internal_has_field2() const;
  public:
  void clear_field2();
  const ::mode::Field& field2() const;
  PROTOBUF_NODISCARD ::mode::Field* release_field2();
  ::mode::Field* mutable_field2();
  void set_allocated_field2(::mode::Field* field2);
  private:
  const ::mode::Field& _internal_field2() const;
  ::mode::Field* _internal_mutable_field2();
  public:
  void unsafe_arena_set_allocated_field2(
      ::mode::Field* field2);
  ::mode::Field* unsafe_arena_release_field2();

  // @@protoc_insertion_point(class_scope:mode.FieldPair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::mode::Field* field1_;
  ::mode::Field* field2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mode_2eproto;
};
// -------------------------------------------------------------------

class ProjectedField final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mode.ProjectedField) */ {
 public:
  inline ProjectedField() : ProjectedField(nullptr) {}
  ~ProjectedField() override;
  explicit constexpr ProjectedField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProjectedField(const ProjectedField& from);
  ProjectedField(ProjectedField&& from) noexcept
    : ProjectedField() {
    *this = ::std::move(from);
  }

  inline ProjectedField& operator=(const ProjectedField& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectedField& operator=(ProjectedField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectedField& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectedField* internal_default_instance() {
    return reinterpret_cast<const ProjectedField*>(
               &_ProjectedField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ProjectedField& a, ProjectedField& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectedField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectedField* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProjectedField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProjectedField>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProjectedField& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProjectedField& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProjectedField* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mode.ProjectedField";
  }
  protected:
  explicit ProjectedField(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRenameFieldNumber = 2,
    kFieldFieldNumber = 1,
  };
  // optional string rename = 2;
  bool has_rename() const;
  private:
  bool _internal_has_rename() const;
  public:
  void clear_rename();
  const std::string& rename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rename();
  PROTOBUF_NODISCARD std::string* release_rename();
  void set_allocated_rename(std::string* rename);
  private:
  const std::string& _internal_rename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rename(const std::string& value);
  std::string* _internal_mutable_rename();
  public:

  // .mode.Field field = 1;
  bool has_field() const;
  private:
  bool _internal_has_field() const;
  public:
  void clear_field();
  const ::mode::Field& field() const;
  PROTOBUF_NODISCARD ::mode::Field* release_field();
  ::mode::Field* mutable_field();
  void set_allocated_field(::mode::Field* field);
  private:
  const ::mode::Field& _internal_field() const;
  ::mode::Field* _internal_mutable_field();
  public:
  void unsafe_arena_set_allocated_field(
      ::mode::Field* field);
  ::mode::Field* unsafe_arena_release_field();

  // @@protoc_insertion_point(class_scope:mode.ProjectedField)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rename_;
  ::mode::Field* field_;
  friend struct ::TableStruct_mode_2eproto;
};
// -------------------------------------------------------------------

class Filter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mode.Filter) */ {
 public:
  inline Filter() : Filter(nullptr) {}
  ~Filter() override;
  explicit constexpr Filter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Filter(const Filter& from);
  Filter(Filter&& from) noexcept
    : Filter() {
    *this = ::std::move(from);
  }

  inline Filter& operator=(const Filter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Filter& operator=(Filter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Filter& default_instance() {
    return *internal_default_instance();
  }
  static inline const Filter* internal_default_instance() {
    return reinterpret_cast<const Filter*>(
               &_Filter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Filter& a, Filter& b) {
    a.Swap(&b);
  }
  inline void Swap(Filter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Filter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Filter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Filter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Filter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Filter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Filter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mode.Filter";
  }
  protected:
  explicit Filter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperatorFieldNumber = 2,
    kValueFieldNumber = 3,
    kFunctionFieldNumber = 4,
    kFieldFieldNumber = 1,
  };
  // string operator = 2;
  void clear_operator_();
  const std::string& operator_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operator_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operator_();
  PROTOBUF_NODISCARD std::string* release_operator_();
  void set_allocated_operator_(std::string* operator_);
  private:
  const std::string& _internal_operator_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operator_(const std::string& value);
  std::string* _internal_mutable_operator_();
  public:

  // string value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // string function = 4;
  void clear_function();
  const std::string& function() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_function(ArgT0&& arg0, ArgT... args);
  std::string* mutable_function();
  PROTOBUF_NODISCARD std::string* release_function();
  void set_allocated_function(std::string* function);
  private:
  const std::string& _internal_function() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_function(const std::string& value);
  std::string* _internal_mutable_function();
  public:

  // .mode.Field field = 1;
  bool has_field() const;
  private:
  bool _internal_has_field() const;
  public:
  void clear_field();
  const ::mode::Field& field() const;
  PROTOBUF_NODISCARD ::mode::Field* release_field();
  ::mode::Field* mutable_field();
  void set_allocated_field(::mode::Field* field);
  private:
  const ::mode::Field& _internal_field() const;
  ::mode::Field* _internal_mutable_field();
  public:
  void unsafe_arena_set_allocated_field(
      ::mode::Field* field);
  ::mode::Field* unsafe_arena_release_field();

  // @@protoc_insertion_point(class_scope:mode.Filter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operator__;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_;
  ::mode::Field* field_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mode_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Row

// repeated bytes values = 2;
inline int Row::_internal_values_size() const {
  return values_.size();
}
inline int Row::values_size() const {
  return _internal_values_size();
}
inline void Row::clear_values() {
  values_.Clear();
}
inline std::string* Row::add_values() {
  std::string* _s = _internal_add_values();
  // @@protoc_insertion_point(field_add_mutable:mode.Row.values)
  return _s;
}
inline const std::string& Row::_internal_values(int index) const {
  return values_.Get(index);
}
inline const std::string& Row::values(int index) const {
  // @@protoc_insertion_point(field_get:mode.Row.values)
  return _internal_values(index);
}
inline std::string* Row::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:mode.Row.values)
  return values_.Mutable(index);
}
inline void Row::set_values(int index, const std::string& value) {
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:mode.Row.values)
}
inline void Row::set_values(int index, std::string&& value) {
  values_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:mode.Row.values)
}
inline void Row::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mode.Row.values)
}
inline void Row::set_values(int index, const void* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mode.Row.values)
}
inline std::string* Row::_internal_add_values() {
  return values_.Add();
}
inline void Row::add_values(const std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mode.Row.values)
}
inline void Row::add_values(std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mode.Row.values)
}
inline void Row::add_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mode.Row.values)
}
inline void Row::add_values(const void* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mode.Row.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Row::values() const {
  // @@protoc_insertion_point(field_list:mode.Row.values)
  return values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Row::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:mode.Row.values)
  return &values_;
}

// -------------------------------------------------------------------

// GenericTable

// repeated string cols = 1;
inline int GenericTable::_internal_cols_size() const {
  return cols_.size();
}
inline int GenericTable::cols_size() const {
  return _internal_cols_size();
}
inline void GenericTable::clear_cols() {
  cols_.Clear();
}
inline std::string* GenericTable::add_cols() {
  std::string* _s = _internal_add_cols();
  // @@protoc_insertion_point(field_add_mutable:mode.GenericTable.cols)
  return _s;
}
inline const std::string& GenericTable::_internal_cols(int index) const {
  return cols_.Get(index);
}
inline const std::string& GenericTable::cols(int index) const {
  // @@protoc_insertion_point(field_get:mode.GenericTable.cols)
  return _internal_cols(index);
}
inline std::string* GenericTable::mutable_cols(int index) {
  // @@protoc_insertion_point(field_mutable:mode.GenericTable.cols)
  return cols_.Mutable(index);
}
inline void GenericTable::set_cols(int index, const std::string& value) {
  cols_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:mode.GenericTable.cols)
}
inline void GenericTable::set_cols(int index, std::string&& value) {
  cols_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:mode.GenericTable.cols)
}
inline void GenericTable::set_cols(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  cols_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mode.GenericTable.cols)
}
inline void GenericTable::set_cols(int index, const char* value, size_t size) {
  cols_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mode.GenericTable.cols)
}
inline std::string* GenericTable::_internal_add_cols() {
  return cols_.Add();
}
inline void GenericTable::add_cols(const std::string& value) {
  cols_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mode.GenericTable.cols)
}
inline void GenericTable::add_cols(std::string&& value) {
  cols_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mode.GenericTable.cols)
}
inline void GenericTable::add_cols(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  cols_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mode.GenericTable.cols)
}
inline void GenericTable::add_cols(const char* value, size_t size) {
  cols_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mode.GenericTable.cols)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GenericTable::cols() const {
  // @@protoc_insertion_point(field_list:mode.GenericTable.cols)
  return cols_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GenericTable::mutable_cols() {
  // @@protoc_insertion_point(field_mutable_list:mode.GenericTable.cols)
  return &cols_;
}

// repeated .mode.Row rows = 2;
inline int GenericTable::_internal_rows_size() const {
  return rows_.size();
}
inline int GenericTable::rows_size() const {
  return _internal_rows_size();
}
inline void GenericTable::clear_rows() {
  rows_.Clear();
}
inline ::mode::Row* GenericTable::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:mode.GenericTable.rows)
  return rows_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Row >*
GenericTable::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:mode.GenericTable.rows)
  return &rows_;
}
inline const ::mode::Row& GenericTable::_internal_rows(int index) const {
  return rows_.Get(index);
}
inline const ::mode::Row& GenericTable::rows(int index) const {
  // @@protoc_insertion_point(field_get:mode.GenericTable.rows)
  return _internal_rows(index);
}
inline ::mode::Row* GenericTable::_internal_add_rows() {
  return rows_.Add();
}
inline ::mode::Row* GenericTable::add_rows() {
  ::mode::Row* _add = _internal_add_rows();
  // @@protoc_insertion_point(field_add:mode.GenericTable.rows)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Row >&
GenericTable::rows() const {
  // @@protoc_insertion_point(field_list:mode.GenericTable.rows)
  return rows_;
}

// repeated string types = 3;
inline int GenericTable::_internal_types_size() const {
  return types_.size();
}
inline int GenericTable::types_size() const {
  return _internal_types_size();
}
inline void GenericTable::clear_types() {
  types_.Clear();
}
inline std::string* GenericTable::add_types() {
  std::string* _s = _internal_add_types();
  // @@protoc_insertion_point(field_add_mutable:mode.GenericTable.types)
  return _s;
}
inline const std::string& GenericTable::_internal_types(int index) const {
  return types_.Get(index);
}
inline const std::string& GenericTable::types(int index) const {
  // @@protoc_insertion_point(field_get:mode.GenericTable.types)
  return _internal_types(index);
}
inline std::string* GenericTable::mutable_types(int index) {
  // @@protoc_insertion_point(field_mutable:mode.GenericTable.types)
  return types_.Mutable(index);
}
inline void GenericTable::set_types(int index, const std::string& value) {
  types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:mode.GenericTable.types)
}
inline void GenericTable::set_types(int index, std::string&& value) {
  types_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:mode.GenericTable.types)
}
inline void GenericTable::set_types(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mode.GenericTable.types)
}
inline void GenericTable::set_types(int index, const char* value, size_t size) {
  types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mode.GenericTable.types)
}
inline std::string* GenericTable::_internal_add_types() {
  return types_.Add();
}
inline void GenericTable::add_types(const std::string& value) {
  types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mode.GenericTable.types)
}
inline void GenericTable::add_types(std::string&& value) {
  types_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mode.GenericTable.types)
}
inline void GenericTable::add_types(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mode.GenericTable.types)
}
inline void GenericTable::add_types(const char* value, size_t size) {
  types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mode.GenericTable.types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GenericTable::types() const {
  // @@protoc_insertion_point(field_list:mode.GenericTable.types)
  return types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GenericTable::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:mode.GenericTable.types)
  return &types_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// QueryLayerResponse

// map<string, .mode.GenericTable> tables = 1;
inline int QueryLayerResponse::_internal_tables_size() const {
  return tables_.size();
}
inline int QueryLayerResponse::tables_size() const {
  return _internal_tables_size();
}
inline void QueryLayerResponse::clear_tables() {
  tables_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >&
QueryLayerResponse::_internal_tables() const {
  return tables_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >&
QueryLayerResponse::tables() const {
  // @@protoc_insertion_point(field_map:mode.QueryLayerResponse.tables)
  return _internal_tables();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >*
QueryLayerResponse::_internal_mutable_tables() {
  return tables_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >*
QueryLayerResponse::mutable_tables() {
  // @@protoc_insertion_point(field_mutable_map:mode.QueryLayerResponse.tables)
  return _internal_mutable_tables();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// QueryLayerStateResponse

// map<string, .mode.GenericTable> chainTables = 1;
inline int QueryLayerStateResponse::_internal_chaintables_size() const {
  return chaintables_.size();
}
inline int QueryLayerStateResponse::chaintables_size() const {
  return _internal_chaintables_size();
}
inline void QueryLayerStateResponse::clear_chaintables() {
  chaintables_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >&
QueryLayerStateResponse::_internal_chaintables() const {
  return chaintables_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >&
QueryLayerStateResponse::chaintables() const {
  // @@protoc_insertion_point(field_map:mode.QueryLayerStateResponse.chainTables)
  return _internal_chaintables();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >*
QueryLayerStateResponse::_internal_mutable_chaintables() {
  return chaintables_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >*
QueryLayerStateResponse::mutable_chaintables() {
  // @@protoc_insertion_point(field_mutable_map:mode.QueryLayerStateResponse.chainTables)
  return _internal_mutable_chaintables();
}

// map<string, .mode.GenericTable> worldTables = 2;
inline int QueryLayerStateResponse::_internal_worldtables_size() const {
  return worldtables_.size();
}
inline int QueryLayerStateResponse::worldtables_size() const {
  return _internal_worldtables_size();
}
inline void QueryLayerStateResponse::clear_worldtables() {
  worldtables_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >&
QueryLayerStateResponse::_internal_worldtables() const {
  return worldtables_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >&
QueryLayerStateResponse::worldtables() const {
  // @@protoc_insertion_point(field_map:mode.QueryLayerStateResponse.worldTables)
  return _internal_worldtables();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >*
QueryLayerStateResponse::_internal_mutable_worldtables() {
  return worldtables_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mode::GenericTable >*
QueryLayerStateResponse::mutable_worldtables() {
  // @@protoc_insertion_point(field_mutable_map:mode.QueryLayerStateResponse.worldTables)
  return _internal_mutable_worldtables();
}

// -------------------------------------------------------------------

// QueryLayerStateStreamResponse

// .mode.QueryLayerStateResponse inserted = 1;
inline bool QueryLayerStateStreamResponse::_internal_has_inserted() const {
  return this != internal_default_instance() && inserted_ != nullptr;
}
inline bool QueryLayerStateStreamResponse::has_inserted() const {
  return _internal_has_inserted();
}
inline void QueryLayerStateStreamResponse::clear_inserted() {
  if (GetArenaForAllocation() == nullptr && inserted_ != nullptr) {
    delete inserted_;
  }
  inserted_ = nullptr;
}
inline const ::mode::QueryLayerStateResponse& QueryLayerStateStreamResponse::_internal_inserted() const {
  const ::mode::QueryLayerStateResponse* p = inserted_;
  return p != nullptr ? *p : reinterpret_cast<const ::mode::QueryLayerStateResponse&>(
      ::mode::_QueryLayerStateResponse_default_instance_);
}
inline const ::mode::QueryLayerStateResponse& QueryLayerStateStreamResponse::inserted() const {
  // @@protoc_insertion_point(field_get:mode.QueryLayerStateStreamResponse.inserted)
  return _internal_inserted();
}
inline void QueryLayerStateStreamResponse::unsafe_arena_set_allocated_inserted(
    ::mode::QueryLayerStateResponse* inserted) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inserted_);
  }
  inserted_ = inserted;
  if (inserted) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mode.QueryLayerStateStreamResponse.inserted)
}
inline ::mode::QueryLayerStateResponse* QueryLayerStateStreamResponse::release_inserted() {
  
  ::mode::QueryLayerStateResponse* temp = inserted_;
  inserted_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mode::QueryLayerStateResponse* QueryLayerStateStreamResponse::unsafe_arena_release_inserted() {
  // @@protoc_insertion_point(field_release:mode.QueryLayerStateStreamResponse.inserted)
  
  ::mode::QueryLayerStateResponse* temp = inserted_;
  inserted_ = nullptr;
  return temp;
}
inline ::mode::QueryLayerStateResponse* QueryLayerStateStreamResponse::_internal_mutable_inserted() {
  
  if (inserted_ == nullptr) {
    auto* p = CreateMaybeMessage<::mode::QueryLayerStateResponse>(GetArenaForAllocation());
    inserted_ = p;
  }
  return inserted_;
}
inline ::mode::QueryLayerStateResponse* QueryLayerStateStreamResponse::mutable_inserted() {
  ::mode::QueryLayerStateResponse* _msg = _internal_mutable_inserted();
  // @@protoc_insertion_point(field_mutable:mode.QueryLayerStateStreamResponse.inserted)
  return _msg;
}
inline void QueryLayerStateStreamResponse::set_allocated_inserted(::mode::QueryLayerStateResponse* inserted) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete inserted_;
  }
  if (inserted) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mode::QueryLayerStateResponse>::GetOwningArena(inserted);
    if (message_arena != submessage_arena) {
      inserted = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inserted, submessage_arena);
    }
    
  } else {
    
  }
  inserted_ = inserted;
  // @@protoc_insertion_point(field_set_allocated:mode.QueryLayerStateStreamResponse.inserted)
}

// .mode.QueryLayerStateResponse updated = 2;
inline bool QueryLayerStateStreamResponse::_internal_has_updated() const {
  return this != internal_default_instance() && updated_ != nullptr;
}
inline bool QueryLayerStateStreamResponse::has_updated() const {
  return _internal_has_updated();
}
inline void QueryLayerStateStreamResponse::clear_updated() {
  if (GetArenaForAllocation() == nullptr && updated_ != nullptr) {
    delete updated_;
  }
  updated_ = nullptr;
}
inline const ::mode::QueryLayerStateResponse& QueryLayerStateStreamResponse::_internal_updated() const {
  const ::mode::QueryLayerStateResponse* p = updated_;
  return p != nullptr ? *p : reinterpret_cast<const ::mode::QueryLayerStateResponse&>(
      ::mode::_QueryLayerStateResponse_default_instance_);
}
inline const ::mode::QueryLayerStateResponse& QueryLayerStateStreamResponse::updated() const {
  // @@protoc_insertion_point(field_get:mode.QueryLayerStateStreamResponse.updated)
  return _internal_updated();
}
inline void QueryLayerStateStreamResponse::unsafe_arena_set_allocated_updated(
    ::mode::QueryLayerStateResponse* updated) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_);
  }
  updated_ = updated;
  if (updated) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mode.QueryLayerStateStreamResponse.updated)
}
inline ::mode::QueryLayerStateResponse* QueryLayerStateStreamResponse::release_updated() {
  
  ::mode::QueryLayerStateResponse* temp = updated_;
  updated_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mode::QueryLayerStateResponse* QueryLayerStateStreamResponse::unsafe_arena_release_updated() {
  // @@protoc_insertion_point(field_release:mode.QueryLayerStateStreamResponse.updated)
  
  ::mode::QueryLayerStateResponse* temp = updated_;
  updated_ = nullptr;
  return temp;
}
inline ::mode::QueryLayerStateResponse* QueryLayerStateStreamResponse::_internal_mutable_updated() {
  
  if (updated_ == nullptr) {
    auto* p = CreateMaybeMessage<::mode::QueryLayerStateResponse>(GetArenaForAllocation());
    updated_ = p;
  }
  return updated_;
}
inline ::mode::QueryLayerStateResponse* QueryLayerStateStreamResponse::mutable_updated() {
  ::mode::QueryLayerStateResponse* _msg = _internal_mutable_updated();
  // @@protoc_insertion_point(field_mutable:mode.QueryLayerStateStreamResponse.updated)
  return _msg;
}
inline void QueryLayerStateStreamResponse::set_allocated_updated(::mode::QueryLayerStateResponse* updated) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete updated_;
  }
  if (updated) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mode::QueryLayerStateResponse>::GetOwningArena(updated);
    if (message_arena != submessage_arena) {
      updated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated, submessage_arena);
    }
    
  } else {
    
  }
  updated_ = updated;
  // @@protoc_insertion_point(field_set_allocated:mode.QueryLayerStateStreamResponse.updated)
}

// .mode.QueryLayerStateResponse deleted = 3;
inline bool QueryLayerStateStreamResponse::_internal_has_deleted() const {
  return this != internal_default_instance() && deleted_ != nullptr;
}
inline bool QueryLayerStateStreamResponse::has_deleted() const {
  return _internal_has_deleted();
}
inline void QueryLayerStateStreamResponse::clear_deleted() {
  if (GetArenaForAllocation() == nullptr && deleted_ != nullptr) {
    delete deleted_;
  }
  deleted_ = nullptr;
}
inline const ::mode::QueryLayerStateResponse& QueryLayerStateStreamResponse::_internal_deleted() const {
  const ::mode::QueryLayerStateResponse* p = deleted_;
  return p != nullptr ? *p : reinterpret_cast<const ::mode::QueryLayerStateResponse&>(
      ::mode::_QueryLayerStateResponse_default_instance_);
}
inline const ::mode::QueryLayerStateResponse& QueryLayerStateStreamResponse::deleted() const {
  // @@protoc_insertion_point(field_get:mode.QueryLayerStateStreamResponse.deleted)
  return _internal_deleted();
}
inline void QueryLayerStateStreamResponse::unsafe_arena_set_allocated_deleted(
    ::mode::QueryLayerStateResponse* deleted) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deleted_);
  }
  deleted_ = deleted;
  if (deleted) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mode.QueryLayerStateStreamResponse.deleted)
}
inline ::mode::QueryLayerStateResponse* QueryLayerStateStreamResponse::release_deleted() {
  
  ::mode::QueryLayerStateResponse* temp = deleted_;
  deleted_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mode::QueryLayerStateResponse* QueryLayerStateStreamResponse::unsafe_arena_release_deleted() {
  // @@protoc_insertion_point(field_release:mode.QueryLayerStateStreamResponse.deleted)
  
  ::mode::QueryLayerStateResponse* temp = deleted_;
  deleted_ = nullptr;
  return temp;
}
inline ::mode::QueryLayerStateResponse* QueryLayerStateStreamResponse::_internal_mutable_deleted() {
  
  if (deleted_ == nullptr) {
    auto* p = CreateMaybeMessage<::mode::QueryLayerStateResponse>(GetArenaForAllocation());
    deleted_ = p;
  }
  return deleted_;
}
inline ::mode::QueryLayerStateResponse* QueryLayerStateStreamResponse::mutable_deleted() {
  ::mode::QueryLayerStateResponse* _msg = _internal_mutable_deleted();
  // @@protoc_insertion_point(field_mutable:mode.QueryLayerStateStreamResponse.deleted)
  return _msg;
}
inline void QueryLayerStateStreamResponse::set_allocated_deleted(::mode::QueryLayerStateResponse* deleted) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete deleted_;
  }
  if (deleted) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mode::QueryLayerStateResponse>::GetOwningArena(deleted);
    if (message_arena != submessage_arena) {
      deleted = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deleted, submessage_arena);
    }
    
  } else {
    
  }
  deleted_ = deleted;
  // @@protoc_insertion_point(field_set_allocated:mode.QueryLayerStateStreamResponse.deleted)
}

// -------------------------------------------------------------------

// Namespace

// string chainId = 1;
inline void Namespace::clear_chainid() {
  chainid_.ClearToEmpty();
}
inline const std::string& Namespace::chainid() const {
  // @@protoc_insertion_point(field_get:mode.Namespace.chainId)
  return _internal_chainid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Namespace::set_chainid(ArgT0&& arg0, ArgT... args) {
 
 chainid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mode.Namespace.chainId)
}
inline std::string* Namespace::mutable_chainid() {
  std::string* _s = _internal_mutable_chainid();
  // @@protoc_insertion_point(field_mutable:mode.Namespace.chainId)
  return _s;
}
inline const std::string& Namespace::_internal_chainid() const {
  return chainid_.Get();
}
inline void Namespace::_internal_set_chainid(const std::string& value) {
  
  chainid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Namespace::_internal_mutable_chainid() {
  
  return chainid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Namespace::release_chainid() {
  // @@protoc_insertion_point(field_release:mode.Namespace.chainId)
  return chainid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Namespace::set_allocated_chainid(std::string* chainid) {
  if (chainid != nullptr) {
    
  } else {
    
  }
  chainid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chainid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chainid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    chainid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mode.Namespace.chainId)
}

// string worldAddress = 2;
inline void Namespace::clear_worldaddress() {
  worldaddress_.ClearToEmpty();
}
inline const std::string& Namespace::worldaddress() const {
  // @@protoc_insertion_point(field_get:mode.Namespace.worldAddress)
  return _internal_worldaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Namespace::set_worldaddress(ArgT0&& arg0, ArgT... args) {
 
 worldaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mode.Namespace.worldAddress)
}
inline std::string* Namespace::mutable_worldaddress() {
  std::string* _s = _internal_mutable_worldaddress();
  // @@protoc_insertion_point(field_mutable:mode.Namespace.worldAddress)
  return _s;
}
inline const std::string& Namespace::_internal_worldaddress() const {
  return worldaddress_.Get();
}
inline void Namespace::_internal_set_worldaddress(const std::string& value) {
  
  worldaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Namespace::_internal_mutable_worldaddress() {
  
  return worldaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Namespace::release_worldaddress() {
  // @@protoc_insertion_point(field_release:mode.Namespace.worldAddress)
  return worldaddress_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Namespace::set_allocated_worldaddress(std::string* worldaddress) {
  if (worldaddress != nullptr) {
    
  } else {
    
  }
  worldaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), worldaddress,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (worldaddress_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    worldaddress_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mode.Namespace.worldAddress)
}

// -------------------------------------------------------------------

// StateRequest

// .mode.Namespace namespace = 1;
inline bool StateRequest::_internal_has_namespace_() const {
  return this != internal_default_instance() && namespace__ != nullptr;
}
inline bool StateRequest::has_namespace_() const {
  return _internal_has_namespace_();
}
inline void StateRequest::clear_namespace_() {
  if (GetArenaForAllocation() == nullptr && namespace__ != nullptr) {
    delete namespace__;
  }
  namespace__ = nullptr;
}
inline const ::mode::Namespace& StateRequest::_internal_namespace_() const {
  const ::mode::Namespace* p = namespace__;
  return p != nullptr ? *p : reinterpret_cast<const ::mode::Namespace&>(
      ::mode::_Namespace_default_instance_);
}
inline const ::mode::Namespace& StateRequest::namespace_() const {
  // @@protoc_insertion_point(field_get:mode.StateRequest.namespace)
  return _internal_namespace_();
}
inline void StateRequest::unsafe_arena_set_allocated_namespace_(
    ::mode::Namespace* namespace_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace__);
  }
  namespace__ = namespace_;
  if (namespace_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mode.StateRequest.namespace)
}
inline ::mode::Namespace* StateRequest::release_namespace_() {
  
  ::mode::Namespace* temp = namespace__;
  namespace__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mode::Namespace* StateRequest::unsafe_arena_release_namespace_() {
  // @@protoc_insertion_point(field_release:mode.StateRequest.namespace)
  
  ::mode::Namespace* temp = namespace__;
  namespace__ = nullptr;
  return temp;
}
inline ::mode::Namespace* StateRequest::_internal_mutable_namespace_() {
  
  if (namespace__ == nullptr) {
    auto* p = CreateMaybeMessage<::mode::Namespace>(GetArenaForAllocation());
    namespace__ = p;
  }
  return namespace__;
}
inline ::mode::Namespace* StateRequest::mutable_namespace_() {
  ::mode::Namespace* _msg = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:mode.StateRequest.namespace)
  return _msg;
}
inline void StateRequest::set_allocated_namespace_(::mode::Namespace* namespace_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete namespace__;
  }
  if (namespace_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mode::Namespace>::GetOwningArena(namespace_);
    if (message_arena != submessage_arena) {
      namespace_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_, submessage_arena);
    }
    
  } else {
    
  }
  namespace__ = namespace_;
  // @@protoc_insertion_point(field_set_allocated:mode.StateRequest.namespace)
}

// repeated string worldTables = 2;
inline int StateRequest::_internal_worldtables_size() const {
  return worldtables_.size();
}
inline int StateRequest::worldtables_size() const {
  return _internal_worldtables_size();
}
inline void StateRequest::clear_worldtables() {
  worldtables_.Clear();
}
inline std::string* StateRequest::add_worldtables() {
  std::string* _s = _internal_add_worldtables();
  // @@protoc_insertion_point(field_add_mutable:mode.StateRequest.worldTables)
  return _s;
}
inline const std::string& StateRequest::_internal_worldtables(int index) const {
  return worldtables_.Get(index);
}
inline const std::string& StateRequest::worldtables(int index) const {
  // @@protoc_insertion_point(field_get:mode.StateRequest.worldTables)
  return _internal_worldtables(index);
}
inline std::string* StateRequest::mutable_worldtables(int index) {
  // @@protoc_insertion_point(field_mutable:mode.StateRequest.worldTables)
  return worldtables_.Mutable(index);
}
inline void StateRequest::set_worldtables(int index, const std::string& value) {
  worldtables_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:mode.StateRequest.worldTables)
}
inline void StateRequest::set_worldtables(int index, std::string&& value) {
  worldtables_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:mode.StateRequest.worldTables)
}
inline void StateRequest::set_worldtables(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  worldtables_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mode.StateRequest.worldTables)
}
inline void StateRequest::set_worldtables(int index, const char* value, size_t size) {
  worldtables_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mode.StateRequest.worldTables)
}
inline std::string* StateRequest::_internal_add_worldtables() {
  return worldtables_.Add();
}
inline void StateRequest::add_worldtables(const std::string& value) {
  worldtables_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mode.StateRequest.worldTables)
}
inline void StateRequest::add_worldtables(std::string&& value) {
  worldtables_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mode.StateRequest.worldTables)
}
inline void StateRequest::add_worldtables(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  worldtables_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mode.StateRequest.worldTables)
}
inline void StateRequest::add_worldtables(const char* value, size_t size) {
  worldtables_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mode.StateRequest.worldTables)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StateRequest::worldtables() const {
  // @@protoc_insertion_point(field_list:mode.StateRequest.worldTables)
  return worldtables_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StateRequest::mutable_worldtables() {
  // @@protoc_insertion_point(field_mutable_list:mode.StateRequest.worldTables)
  return &worldtables_;
}

// repeated string chainTables = 3;
inline int StateRequest::_internal_chaintables_size() const {
  return chaintables_.size();
}
inline int StateRequest::chaintables_size() const {
  return _internal_chaintables_size();
}
inline void StateRequest::clear_chaintables() {
  chaintables_.Clear();
}
inline std::string* StateRequest::add_chaintables() {
  std::string* _s = _internal_add_chaintables();
  // @@protoc_insertion_point(field_add_mutable:mode.StateRequest.chainTables)
  return _s;
}
inline const std::string& StateRequest::_internal_chaintables(int index) const {
  return chaintables_.Get(index);
}
inline const std::string& StateRequest::chaintables(int index) const {
  // @@protoc_insertion_point(field_get:mode.StateRequest.chainTables)
  return _internal_chaintables(index);
}
inline std::string* StateRequest::mutable_chaintables(int index) {
  // @@protoc_insertion_point(field_mutable:mode.StateRequest.chainTables)
  return chaintables_.Mutable(index);
}
inline void StateRequest::set_chaintables(int index, const std::string& value) {
  chaintables_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:mode.StateRequest.chainTables)
}
inline void StateRequest::set_chaintables(int index, std::string&& value) {
  chaintables_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:mode.StateRequest.chainTables)
}
inline void StateRequest::set_chaintables(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  chaintables_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mode.StateRequest.chainTables)
}
inline void StateRequest::set_chaintables(int index, const char* value, size_t size) {
  chaintables_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mode.StateRequest.chainTables)
}
inline std::string* StateRequest::_internal_add_chaintables() {
  return chaintables_.Add();
}
inline void StateRequest::add_chaintables(const std::string& value) {
  chaintables_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mode.StateRequest.chainTables)
}
inline void StateRequest::add_chaintables(std::string&& value) {
  chaintables_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mode.StateRequest.chainTables)
}
inline void StateRequest::add_chaintables(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  chaintables_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mode.StateRequest.chainTables)
}
inline void StateRequest::add_chaintables(const char* value, size_t size) {
  chaintables_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mode.StateRequest.chainTables)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StateRequest::chaintables() const {
  // @@protoc_insertion_point(field_list:mode.StateRequest.chainTables)
  return chaintables_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StateRequest::mutable_chaintables() {
  // @@protoc_insertion_point(field_mutable_list:mode.StateRequest.chainTables)
  return &chaintables_;
}

// -------------------------------------------------------------------

// Single__StateRequest

// .mode.Namespace namespace = 1;
inline bool Single__StateRequest::_internal_has_namespace_() const {
  return this != internal_default_instance() && namespace__ != nullptr;
}
inline bool Single__StateRequest::has_namespace_() const {
  return _internal_has_namespace_();
}
inline void Single__StateRequest::clear_namespace_() {
  if (GetArenaForAllocation() == nullptr && namespace__ != nullptr) {
    delete namespace__;
  }
  namespace__ = nullptr;
}
inline const ::mode::Namespace& Single__StateRequest::_internal_namespace_() const {
  const ::mode::Namespace* p = namespace__;
  return p != nullptr ? *p : reinterpret_cast<const ::mode::Namespace&>(
      ::mode::_Namespace_default_instance_);
}
inline const ::mode::Namespace& Single__StateRequest::namespace_() const {
  // @@protoc_insertion_point(field_get:mode.Single__StateRequest.namespace)
  return _internal_namespace_();
}
inline void Single__StateRequest::unsafe_arena_set_allocated_namespace_(
    ::mode::Namespace* namespace_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace__);
  }
  namespace__ = namespace_;
  if (namespace_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mode.Single__StateRequest.namespace)
}
inline ::mode::Namespace* Single__StateRequest::release_namespace_() {
  
  ::mode::Namespace* temp = namespace__;
  namespace__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mode::Namespace* Single__StateRequest::unsafe_arena_release_namespace_() {
  // @@protoc_insertion_point(field_release:mode.Single__StateRequest.namespace)
  
  ::mode::Namespace* temp = namespace__;
  namespace__ = nullptr;
  return temp;
}
inline ::mode::Namespace* Single__StateRequest::_internal_mutable_namespace_() {
  
  if (namespace__ == nullptr) {
    auto* p = CreateMaybeMessage<::mode::Namespace>(GetArenaForAllocation());
    namespace__ = p;
  }
  return namespace__;
}
inline ::mode::Namespace* Single__StateRequest::mutable_namespace_() {
  ::mode::Namespace* _msg = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:mode.Single__StateRequest.namespace)
  return _msg;
}
inline void Single__StateRequest::set_allocated_namespace_(::mode::Namespace* namespace_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete namespace__;
  }
  if (namespace_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mode::Namespace>::GetOwningArena(namespace_);
    if (message_arena != submessage_arena) {
      namespace_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_, submessage_arena);
    }
    
  } else {
    
  }
  namespace__ = namespace_;
  // @@protoc_insertion_point(field_set_allocated:mode.Single__StateRequest.namespace)
}

// string table = 2;
inline void Single__StateRequest::clear_table() {
  table_.ClearToEmpty();
}
inline const std::string& Single__StateRequest::table() const {
  // @@protoc_insertion_point(field_get:mode.Single__StateRequest.table)
  return _internal_table();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Single__StateRequest::set_table(ArgT0&& arg0, ArgT... args) {
 
 table_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mode.Single__StateRequest.table)
}
inline std::string* Single__StateRequest::mutable_table() {
  std::string* _s = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:mode.Single__StateRequest.table)
  return _s;
}
inline const std::string& Single__StateRequest::_internal_table() const {
  return table_.Get();
}
inline void Single__StateRequest::_internal_set_table(const std::string& value) {
  
  table_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Single__StateRequest::_internal_mutable_table() {
  
  return table_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Single__StateRequest::release_table() {
  // @@protoc_insertion_point(field_release:mode.Single__StateRequest.table)
  return table_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Single__StateRequest::set_allocated_table(std::string* table) {
  if (table != nullptr) {
    
  } else {
    
  }
  table_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (table_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    table_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mode.Single__StateRequest.table)
}

// repeated .mode.Filter filter = 3;
inline int Single__StateRequest::_internal_filter_size() const {
  return filter_.size();
}
inline int Single__StateRequest::filter_size() const {
  return _internal_filter_size();
}
inline void Single__StateRequest::clear_filter() {
  filter_.Clear();
}
inline ::mode::Filter* Single__StateRequest::mutable_filter(int index) {
  // @@protoc_insertion_point(field_mutable:mode.Single__StateRequest.filter)
  return filter_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Filter >*
Single__StateRequest::mutable_filter() {
  // @@protoc_insertion_point(field_mutable_list:mode.Single__StateRequest.filter)
  return &filter_;
}
inline const ::mode::Filter& Single__StateRequest::_internal_filter(int index) const {
  return filter_.Get(index);
}
inline const ::mode::Filter& Single__StateRequest::filter(int index) const {
  // @@protoc_insertion_point(field_get:mode.Single__StateRequest.filter)
  return _internal_filter(index);
}
inline ::mode::Filter* Single__StateRequest::_internal_add_filter() {
  return filter_.Add();
}
inline ::mode::Filter* Single__StateRequest::add_filter() {
  ::mode::Filter* _add = _internal_add_filter();
  // @@protoc_insertion_point(field_add:mode.Single__StateRequest.filter)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Filter >&
Single__StateRequest::filter() const {
  // @@protoc_insertion_point(field_list:mode.Single__StateRequest.filter)
  return filter_;
}

// repeated .mode.ProjectedField project = 4;
inline int Single__StateRequest::_internal_project_size() const {
  return project_.size();
}
inline int Single__StateRequest::project_size() const {
  return _internal_project_size();
}
inline void Single__StateRequest::clear_project() {
  project_.Clear();
}
inline ::mode::ProjectedField* Single__StateRequest::mutable_project(int index) {
  // @@protoc_insertion_point(field_mutable:mode.Single__StateRequest.project)
  return project_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::ProjectedField >*
Single__StateRequest::mutable_project() {
  // @@protoc_insertion_point(field_mutable_list:mode.Single__StateRequest.project)
  return &project_;
}
inline const ::mode::ProjectedField& Single__StateRequest::_internal_project(int index) const {
  return project_.Get(index);
}
inline const ::mode::ProjectedField& Single__StateRequest::project(int index) const {
  // @@protoc_insertion_point(field_get:mode.Single__StateRequest.project)
  return _internal_project(index);
}
inline ::mode::ProjectedField* Single__StateRequest::_internal_add_project() {
  return project_.Add();
}
inline ::mode::ProjectedField* Single__StateRequest::add_project() {
  ::mode::ProjectedField* _add = _internal_add_project();
  // @@protoc_insertion_point(field_add:mode.Single__StateRequest.project)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::ProjectedField >&
Single__StateRequest::project() const {
  // @@protoc_insertion_point(field_list:mode.Single__StateRequest.project)
  return project_;
}

// -------------------------------------------------------------------

// FindRequest

// string from = 1;
inline void FindRequest::clear_from() {
  from_.ClearToEmpty();
}
inline const std::string& FindRequest::from() const {
  // @@protoc_insertion_point(field_get:mode.FindRequest.from)
  return _internal_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FindRequest::set_from(ArgT0&& arg0, ArgT... args) {
 
 from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mode.FindRequest.from)
}
inline std::string* FindRequest::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:mode.FindRequest.from)
  return _s;
}
inline const std::string& FindRequest::_internal_from() const {
  return from_.Get();
}
inline void FindRequest::_internal_set_from(const std::string& value) {
  
  from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FindRequest::_internal_mutable_from() {
  
  return from_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FindRequest::release_from() {
  // @@protoc_insertion_point(field_release:mode.FindRequest.from)
  return from_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FindRequest::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    
  } else {
    
  }
  from_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    from_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mode.FindRequest.from)
}

// repeated .mode.Filter filter = 2;
inline int FindRequest::_internal_filter_size() const {
  return filter_.size();
}
inline int FindRequest::filter_size() const {
  return _internal_filter_size();
}
inline void FindRequest::clear_filter() {
  filter_.Clear();
}
inline ::mode::Filter* FindRequest::mutable_filter(int index) {
  // @@protoc_insertion_point(field_mutable:mode.FindRequest.filter)
  return filter_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Filter >*
FindRequest::mutable_filter() {
  // @@protoc_insertion_point(field_mutable_list:mode.FindRequest.filter)
  return &filter_;
}
inline const ::mode::Filter& FindRequest::_internal_filter(int index) const {
  return filter_.Get(index);
}
inline const ::mode::Filter& FindRequest::filter(int index) const {
  // @@protoc_insertion_point(field_get:mode.FindRequest.filter)
  return _internal_filter(index);
}
inline ::mode::Filter* FindRequest::_internal_add_filter() {
  return filter_.Add();
}
inline ::mode::Filter* FindRequest::add_filter() {
  ::mode::Filter* _add = _internal_add_filter();
  // @@protoc_insertion_point(field_add:mode.FindRequest.filter)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Filter >&
FindRequest::filter() const {
  // @@protoc_insertion_point(field_list:mode.FindRequest.filter)
  return filter_;
}

// repeated .mode.ProjectedField project = 3;
inline int FindRequest::_internal_project_size() const {
  return project_.size();
}
inline int FindRequest::project_size() const {
  return _internal_project_size();
}
inline void FindRequest::clear_project() {
  project_.Clear();
}
inline ::mode::ProjectedField* FindRequest::mutable_project(int index) {
  // @@protoc_insertion_point(field_mutable:mode.FindRequest.project)
  return project_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::ProjectedField >*
FindRequest::mutable_project() {
  // @@protoc_insertion_point(field_mutable_list:mode.FindRequest.project)
  return &project_;
}
inline const ::mode::ProjectedField& FindRequest::_internal_project(int index) const {
  return project_.Get(index);
}
inline const ::mode::ProjectedField& FindRequest::project(int index) const {
  // @@protoc_insertion_point(field_get:mode.FindRequest.project)
  return _internal_project(index);
}
inline ::mode::ProjectedField* FindRequest::_internal_add_project() {
  return project_.Add();
}
inline ::mode::ProjectedField* FindRequest::add_project() {
  ::mode::ProjectedField* _add = _internal_add_project();
  // @@protoc_insertion_point(field_add:mode.FindRequest.project)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::ProjectedField >&
FindRequest::project() const {
  // @@protoc_insertion_point(field_list:mode.FindRequest.project)
  return project_;
}

// .mode.Namespace namespace = 4;
inline bool FindRequest::_internal_has_namespace_() const {
  return this != internal_default_instance() && namespace__ != nullptr;
}
inline bool FindRequest::has_namespace_() const {
  return _internal_has_namespace_();
}
inline void FindRequest::clear_namespace_() {
  if (GetArenaForAllocation() == nullptr && namespace__ != nullptr) {
    delete namespace__;
  }
  namespace__ = nullptr;
}
inline const ::mode::Namespace& FindRequest::_internal_namespace_() const {
  const ::mode::Namespace* p = namespace__;
  return p != nullptr ? *p : reinterpret_cast<const ::mode::Namespace&>(
      ::mode::_Namespace_default_instance_);
}
inline const ::mode::Namespace& FindRequest::namespace_() const {
  // @@protoc_insertion_point(field_get:mode.FindRequest.namespace)
  return _internal_namespace_();
}
inline void FindRequest::unsafe_arena_set_allocated_namespace_(
    ::mode::Namespace* namespace_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace__);
  }
  namespace__ = namespace_;
  if (namespace_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mode.FindRequest.namespace)
}
inline ::mode::Namespace* FindRequest::release_namespace_() {
  
  ::mode::Namespace* temp = namespace__;
  namespace__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mode::Namespace* FindRequest::unsafe_arena_release_namespace_() {
  // @@protoc_insertion_point(field_release:mode.FindRequest.namespace)
  
  ::mode::Namespace* temp = namespace__;
  namespace__ = nullptr;
  return temp;
}
inline ::mode::Namespace* FindRequest::_internal_mutable_namespace_() {
  
  if (namespace__ == nullptr) {
    auto* p = CreateMaybeMessage<::mode::Namespace>(GetArenaForAllocation());
    namespace__ = p;
  }
  return namespace__;
}
inline ::mode::Namespace* FindRequest::mutable_namespace_() {
  ::mode::Namespace* _msg = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:mode.FindRequest.namespace)
  return _msg;
}
inline void FindRequest::set_allocated_namespace_(::mode::Namespace* namespace_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete namespace__;
  }
  if (namespace_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mode::Namespace>::GetOwningArena(namespace_);
    if (message_arena != submessage_arena) {
      namespace_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_, submessage_arena);
    }
    
  } else {
    
  }
  namespace__ = namespace_;
  // @@protoc_insertion_point(field_set_allocated:mode.FindRequest.namespace)
}

// .mode.FindRequestOptions options = 5;
inline bool FindRequest::_internal_has_options() const {
  return this != internal_default_instance() && options_ != nullptr;
}
inline bool FindRequest::has_options() const {
  return _internal_has_options();
}
inline void FindRequest::clear_options() {
  if (GetArenaForAllocation() == nullptr && options_ != nullptr) {
    delete options_;
  }
  options_ = nullptr;
}
inline const ::mode::FindRequestOptions& FindRequest::_internal_options() const {
  const ::mode::FindRequestOptions* p = options_;
  return p != nullptr ? *p : reinterpret_cast<const ::mode::FindRequestOptions&>(
      ::mode::_FindRequestOptions_default_instance_);
}
inline const ::mode::FindRequestOptions& FindRequest::options() const {
  // @@protoc_insertion_point(field_get:mode.FindRequest.options)
  return _internal_options();
}
inline void FindRequest::unsafe_arena_set_allocated_options(
    ::mode::FindRequestOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options_);
  }
  options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mode.FindRequest.options)
}
inline ::mode::FindRequestOptions* FindRequest::release_options() {
  
  ::mode::FindRequestOptions* temp = options_;
  options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mode::FindRequestOptions* FindRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:mode.FindRequest.options)
  
  ::mode::FindRequestOptions* temp = options_;
  options_ = nullptr;
  return temp;
}
inline ::mode::FindRequestOptions* FindRequest::_internal_mutable_options() {
  
  if (options_ == nullptr) {
    auto* p = CreateMaybeMessage<::mode::FindRequestOptions>(GetArenaForAllocation());
    options_ = p;
  }
  return options_;
}
inline ::mode::FindRequestOptions* FindRequest::mutable_options() {
  ::mode::FindRequestOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:mode.FindRequest.options)
  return _msg;
}
inline void FindRequest::set_allocated_options(::mode::FindRequestOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mode::FindRequestOptions>::GetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:mode.FindRequest.options)
}

// -------------------------------------------------------------------

// FindAllRequest

// repeated string tables = 1;
inline int FindAllRequest::_internal_tables_size() const {
  return tables_.size();
}
inline int FindAllRequest::tables_size() const {
  return _internal_tables_size();
}
inline void FindAllRequest::clear_tables() {
  tables_.Clear();
}
inline std::string* FindAllRequest::add_tables() {
  std::string* _s = _internal_add_tables();
  // @@protoc_insertion_point(field_add_mutable:mode.FindAllRequest.tables)
  return _s;
}
inline const std::string& FindAllRequest::_internal_tables(int index) const {
  return tables_.Get(index);
}
inline const std::string& FindAllRequest::tables(int index) const {
  // @@protoc_insertion_point(field_get:mode.FindAllRequest.tables)
  return _internal_tables(index);
}
inline std::string* FindAllRequest::mutable_tables(int index) {
  // @@protoc_insertion_point(field_mutable:mode.FindAllRequest.tables)
  return tables_.Mutable(index);
}
inline void FindAllRequest::set_tables(int index, const std::string& value) {
  tables_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:mode.FindAllRequest.tables)
}
inline void FindAllRequest::set_tables(int index, std::string&& value) {
  tables_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:mode.FindAllRequest.tables)
}
inline void FindAllRequest::set_tables(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tables_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mode.FindAllRequest.tables)
}
inline void FindAllRequest::set_tables(int index, const char* value, size_t size) {
  tables_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mode.FindAllRequest.tables)
}
inline std::string* FindAllRequest::_internal_add_tables() {
  return tables_.Add();
}
inline void FindAllRequest::add_tables(const std::string& value) {
  tables_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mode.FindAllRequest.tables)
}
inline void FindAllRequest::add_tables(std::string&& value) {
  tables_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mode.FindAllRequest.tables)
}
inline void FindAllRequest::add_tables(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tables_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mode.FindAllRequest.tables)
}
inline void FindAllRequest::add_tables(const char* value, size_t size) {
  tables_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mode.FindAllRequest.tables)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FindAllRequest::tables() const {
  // @@protoc_insertion_point(field_list:mode.FindAllRequest.tables)
  return tables_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FindAllRequest::mutable_tables() {
  // @@protoc_insertion_point(field_mutable_list:mode.FindAllRequest.tables)
  return &tables_;
}

// .mode.Namespace namespace = 2;
inline bool FindAllRequest::_internal_has_namespace_() const {
  return this != internal_default_instance() && namespace__ != nullptr;
}
inline bool FindAllRequest::has_namespace_() const {
  return _internal_has_namespace_();
}
inline void FindAllRequest::clear_namespace_() {
  if (GetArenaForAllocation() == nullptr && namespace__ != nullptr) {
    delete namespace__;
  }
  namespace__ = nullptr;
}
inline const ::mode::Namespace& FindAllRequest::_internal_namespace_() const {
  const ::mode::Namespace* p = namespace__;
  return p != nullptr ? *p : reinterpret_cast<const ::mode::Namespace&>(
      ::mode::_Namespace_default_instance_);
}
inline const ::mode::Namespace& FindAllRequest::namespace_() const {
  // @@protoc_insertion_point(field_get:mode.FindAllRequest.namespace)
  return _internal_namespace_();
}
inline void FindAllRequest::unsafe_arena_set_allocated_namespace_(
    ::mode::Namespace* namespace_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace__);
  }
  namespace__ = namespace_;
  if (namespace_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mode.FindAllRequest.namespace)
}
inline ::mode::Namespace* FindAllRequest::release_namespace_() {
  
  ::mode::Namespace* temp = namespace__;
  namespace__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mode::Namespace* FindAllRequest::unsafe_arena_release_namespace_() {
  // @@protoc_insertion_point(field_release:mode.FindAllRequest.namespace)
  
  ::mode::Namespace* temp = namespace__;
  namespace__ = nullptr;
  return temp;
}
inline ::mode::Namespace* FindAllRequest::_internal_mutable_namespace_() {
  
  if (namespace__ == nullptr) {
    auto* p = CreateMaybeMessage<::mode::Namespace>(GetArenaForAllocation());
    namespace__ = p;
  }
  return namespace__;
}
inline ::mode::Namespace* FindAllRequest::mutable_namespace_() {
  ::mode::Namespace* _msg = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:mode.FindAllRequest.namespace)
  return _msg;
}
inline void FindAllRequest::set_allocated_namespace_(::mode::Namespace* namespace_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete namespace__;
  }
  if (namespace_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mode::Namespace>::GetOwningArena(namespace_);
    if (message_arena != submessage_arena) {
      namespace_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_, submessage_arena);
    }
    
  } else {
    
  }
  namespace__ = namespace_;
  // @@protoc_insertion_point(field_set_allocated:mode.FindAllRequest.namespace)
}

// .mode.FindRequestOptions options = 3;
inline bool FindAllRequest::_internal_has_options() const {
  return this != internal_default_instance() && options_ != nullptr;
}
inline bool FindAllRequest::has_options() const {
  return _internal_has_options();
}
inline void FindAllRequest::clear_options() {
  if (GetArenaForAllocation() == nullptr && options_ != nullptr) {
    delete options_;
  }
  options_ = nullptr;
}
inline const ::mode::FindRequestOptions& FindAllRequest::_internal_options() const {
  const ::mode::FindRequestOptions* p = options_;
  return p != nullptr ? *p : reinterpret_cast<const ::mode::FindRequestOptions&>(
      ::mode::_FindRequestOptions_default_instance_);
}
inline const ::mode::FindRequestOptions& FindAllRequest::options() const {
  // @@protoc_insertion_point(field_get:mode.FindAllRequest.options)
  return _internal_options();
}
inline void FindAllRequest::unsafe_arena_set_allocated_options(
    ::mode::FindRequestOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options_);
  }
  options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mode.FindAllRequest.options)
}
inline ::mode::FindRequestOptions* FindAllRequest::release_options() {
  
  ::mode::FindRequestOptions* temp = options_;
  options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mode::FindRequestOptions* FindAllRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:mode.FindAllRequest.options)
  
  ::mode::FindRequestOptions* temp = options_;
  options_ = nullptr;
  return temp;
}
inline ::mode::FindRequestOptions* FindAllRequest::_internal_mutable_options() {
  
  if (options_ == nullptr) {
    auto* p = CreateMaybeMessage<::mode::FindRequestOptions>(GetArenaForAllocation());
    options_ = p;
  }
  return options_;
}
inline ::mode::FindRequestOptions* FindAllRequest::mutable_options() {
  ::mode::FindRequestOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:mode.FindAllRequest.options)
  return _msg;
}
inline void FindAllRequest::set_allocated_options(::mode::FindRequestOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mode::FindRequestOptions>::GetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:mode.FindAllRequest.options)
}

// -------------------------------------------------------------------

// JoinRequest

// .mode.FieldPair on = 1;
inline bool JoinRequest::_internal_has_on() const {
  return this != internal_default_instance() && on_ != nullptr;
}
inline bool JoinRequest::has_on() const {
  return _internal_has_on();
}
inline void JoinRequest::clear_on() {
  if (GetArenaForAllocation() == nullptr && on_ != nullptr) {
    delete on_;
  }
  on_ = nullptr;
}
inline const ::mode::FieldPair& JoinRequest::_internal_on() const {
  const ::mode::FieldPair* p = on_;
  return p != nullptr ? *p : reinterpret_cast<const ::mode::FieldPair&>(
      ::mode::_FieldPair_default_instance_);
}
inline const ::mode::FieldPair& JoinRequest::on() const {
  // @@protoc_insertion_point(field_get:mode.JoinRequest.on)
  return _internal_on();
}
inline void JoinRequest::unsafe_arena_set_allocated_on(
    ::mode::FieldPair* on) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(on_);
  }
  on_ = on;
  if (on) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mode.JoinRequest.on)
}
inline ::mode::FieldPair* JoinRequest::release_on() {
  
  ::mode::FieldPair* temp = on_;
  on_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mode::FieldPair* JoinRequest::unsafe_arena_release_on() {
  // @@protoc_insertion_point(field_release:mode.JoinRequest.on)
  
  ::mode::FieldPair* temp = on_;
  on_ = nullptr;
  return temp;
}
inline ::mode::FieldPair* JoinRequest::_internal_mutable_on() {
  
  if (on_ == nullptr) {
    auto* p = CreateMaybeMessage<::mode::FieldPair>(GetArenaForAllocation());
    on_ = p;
  }
  return on_;
}
inline ::mode::FieldPair* JoinRequest::mutable_on() {
  ::mode::FieldPair* _msg = _internal_mutable_on();
  // @@protoc_insertion_point(field_mutable:mode.JoinRequest.on)
  return _msg;
}
inline void JoinRequest::set_allocated_on(::mode::FieldPair* on) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete on_;
  }
  if (on) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mode::FieldPair>::GetOwningArena(on);
    if (message_arena != submessage_arena) {
      on = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, on, submessage_arena);
    }
    
  } else {
    
  }
  on_ = on;
  // @@protoc_insertion_point(field_set_allocated:mode.JoinRequest.on)
}

// repeated .mode.FindRequest children = 2;
inline int JoinRequest::_internal_children_size() const {
  return children_.size();
}
inline int JoinRequest::children_size() const {
  return _internal_children_size();
}
inline void JoinRequest::clear_children() {
  children_.Clear();
}
inline ::mode::FindRequest* JoinRequest::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:mode.JoinRequest.children)
  return children_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::FindRequest >*
JoinRequest::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:mode.JoinRequest.children)
  return &children_;
}
inline const ::mode::FindRequest& JoinRequest::_internal_children(int index) const {
  return children_.Get(index);
}
inline const ::mode::FindRequest& JoinRequest::children(int index) const {
  // @@protoc_insertion_point(field_get:mode.JoinRequest.children)
  return _internal_children(index);
}
inline ::mode::FindRequest* JoinRequest::_internal_add_children() {
  return children_.Add();
}
inline ::mode::FindRequest* JoinRequest::add_children() {
  ::mode::FindRequest* _add = _internal_add_children();
  // @@protoc_insertion_point(field_add:mode.JoinRequest.children)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::FindRequest >&
JoinRequest::children() const {
  // @@protoc_insertion_point(field_list:mode.JoinRequest.children)
  return children_;
}

// .mode.Namespace namespace = 3;
inline bool JoinRequest::_internal_has_namespace_() const {
  return this != internal_default_instance() && namespace__ != nullptr;
}
inline bool JoinRequest::has_namespace_() const {
  return _internal_has_namespace_();
}
inline void JoinRequest::clear_namespace_() {
  if (GetArenaForAllocation() == nullptr && namespace__ != nullptr) {
    delete namespace__;
  }
  namespace__ = nullptr;
}
inline const ::mode::Namespace& JoinRequest::_internal_namespace_() const {
  const ::mode::Namespace* p = namespace__;
  return p != nullptr ? *p : reinterpret_cast<const ::mode::Namespace&>(
      ::mode::_Namespace_default_instance_);
}
inline const ::mode::Namespace& JoinRequest::namespace_() const {
  // @@protoc_insertion_point(field_get:mode.JoinRequest.namespace)
  return _internal_namespace_();
}
inline void JoinRequest::unsafe_arena_set_allocated_namespace_(
    ::mode::Namespace* namespace_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace__);
  }
  namespace__ = namespace_;
  if (namespace_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mode.JoinRequest.namespace)
}
inline ::mode::Namespace* JoinRequest::release_namespace_() {
  
  ::mode::Namespace* temp = namespace__;
  namespace__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mode::Namespace* JoinRequest::unsafe_arena_release_namespace_() {
  // @@protoc_insertion_point(field_release:mode.JoinRequest.namespace)
  
  ::mode::Namespace* temp = namespace__;
  namespace__ = nullptr;
  return temp;
}
inline ::mode::Namespace* JoinRequest::_internal_mutable_namespace_() {
  
  if (namespace__ == nullptr) {
    auto* p = CreateMaybeMessage<::mode::Namespace>(GetArenaForAllocation());
    namespace__ = p;
  }
  return namespace__;
}
inline ::mode::Namespace* JoinRequest::mutable_namespace_() {
  ::mode::Namespace* _msg = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:mode.JoinRequest.namespace)
  return _msg;
}
inline void JoinRequest::set_allocated_namespace_(::mode::Namespace* namespace_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete namespace__;
  }
  if (namespace_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mode::Namespace>::GetOwningArena(namespace_);
    if (message_arena != submessage_arena) {
      namespace_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_, submessage_arena);
    }
    
  } else {
    
  }
  namespace__ = namespace_;
  // @@protoc_insertion_point(field_set_allocated:mode.JoinRequest.namespace)
}

// -------------------------------------------------------------------

// DeleteRequest

// string from = 1;
inline void DeleteRequest::clear_from() {
  from_.ClearToEmpty();
}
inline const std::string& DeleteRequest::from() const {
  // @@protoc_insertion_point(field_get:mode.DeleteRequest.from)
  return _internal_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRequest::set_from(ArgT0&& arg0, ArgT... args) {
 
 from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mode.DeleteRequest.from)
}
inline std::string* DeleteRequest::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:mode.DeleteRequest.from)
  return _s;
}
inline const std::string& DeleteRequest::_internal_from() const {
  return from_.Get();
}
inline void DeleteRequest::_internal_set_from(const std::string& value) {
  
  from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteRequest::_internal_mutable_from() {
  
  return from_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteRequest::release_from() {
  // @@protoc_insertion_point(field_release:mode.DeleteRequest.from)
  return from_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteRequest::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    
  } else {
    
  }
  from_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    from_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mode.DeleteRequest.from)
}

// repeated .mode.Filter filter = 2;
inline int DeleteRequest::_internal_filter_size() const {
  return filter_.size();
}
inline int DeleteRequest::filter_size() const {
  return _internal_filter_size();
}
inline void DeleteRequest::clear_filter() {
  filter_.Clear();
}
inline ::mode::Filter* DeleteRequest::mutable_filter(int index) {
  // @@protoc_insertion_point(field_mutable:mode.DeleteRequest.filter)
  return filter_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Filter >*
DeleteRequest::mutable_filter() {
  // @@protoc_insertion_point(field_mutable_list:mode.DeleteRequest.filter)
  return &filter_;
}
inline const ::mode::Filter& DeleteRequest::_internal_filter(int index) const {
  return filter_.Get(index);
}
inline const ::mode::Filter& DeleteRequest::filter(int index) const {
  // @@protoc_insertion_point(field_get:mode.DeleteRequest.filter)
  return _internal_filter(index);
}
inline ::mode::Filter* DeleteRequest::_internal_add_filter() {
  return filter_.Add();
}
inline ::mode::Filter* DeleteRequest::add_filter() {
  ::mode::Filter* _add = _internal_add_filter();
  // @@protoc_insertion_point(field_add:mode.DeleteRequest.filter)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Filter >&
DeleteRequest::filter() const {
  // @@protoc_insertion_point(field_list:mode.DeleteRequest.filter)
  return filter_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// UpdateRequest

// string target = 1;
inline void UpdateRequest::clear_target() {
  target_.ClearToEmpty();
}
inline const std::string& UpdateRequest::target() const {
  // @@protoc_insertion_point(field_get:mode.UpdateRequest.target)
  return _internal_target();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRequest::set_target(ArgT0&& arg0, ArgT... args) {
 
 target_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mode.UpdateRequest.target)
}
inline std::string* UpdateRequest::mutable_target() {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:mode.UpdateRequest.target)
  return _s;
}
inline const std::string& UpdateRequest::_internal_target() const {
  return target_.Get();
}
inline void UpdateRequest::_internal_set_target(const std::string& value) {
  
  target_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateRequest::_internal_mutable_target() {
  
  return target_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateRequest::release_target() {
  // @@protoc_insertion_point(field_release:mode.UpdateRequest.target)
  return target_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateRequest::set_allocated_target(std::string* target) {
  if (target != nullptr) {
    
  } else {
    
  }
  target_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), target,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (target_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    target_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mode.UpdateRequest.target)
}

// repeated .mode.Filter filter = 2;
inline int UpdateRequest::_internal_filter_size() const {
  return filter_.size();
}
inline int UpdateRequest::filter_size() const {
  return _internal_filter_size();
}
inline void UpdateRequest::clear_filter() {
  filter_.Clear();
}
inline ::mode::Filter* UpdateRequest::mutable_filter(int index) {
  // @@protoc_insertion_point(field_mutable:mode.UpdateRequest.filter)
  return filter_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Filter >*
UpdateRequest::mutable_filter() {
  // @@protoc_insertion_point(field_mutable_list:mode.UpdateRequest.filter)
  return &filter_;
}
inline const ::mode::Filter& UpdateRequest::_internal_filter(int index) const {
  return filter_.Get(index);
}
inline const ::mode::Filter& UpdateRequest::filter(int index) const {
  // @@protoc_insertion_point(field_get:mode.UpdateRequest.filter)
  return _internal_filter(index);
}
inline ::mode::Filter* UpdateRequest::_internal_add_filter() {
  return filter_.Add();
}
inline ::mode::Filter* UpdateRequest::add_filter() {
  ::mode::Filter* _add = _internal_add_filter();
  // @@protoc_insertion_point(field_add:mode.UpdateRequest.filter)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mode::Filter >&
UpdateRequest::filter() const {
  // @@protoc_insertion_point(field_list:mode.UpdateRequest.filter)
  return filter_;
}

// map<string, string> row = 3;
inline int UpdateRequest::_internal_row_size() const {
  return row_.size();
}
inline int UpdateRequest::row_size() const {
  return _internal_row_size();
}
inline void UpdateRequest::clear_row() {
  row_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
UpdateRequest::_internal_row() const {
  return row_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
UpdateRequest::row() const {
  // @@protoc_insertion_point(field_map:mode.UpdateRequest.row)
  return _internal_row();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
UpdateRequest::_internal_mutable_row() {
  return row_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
UpdateRequest::mutable_row() {
  // @@protoc_insertion_point(field_mutable_map:mode.UpdateRequest.row)
  return _internal_mutable_row();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// InsertRequest

// string into = 1;
inline void InsertRequest::clear_into() {
  into_.ClearToEmpty();
}
inline const std::string& InsertRequest::into() const {
  // @@protoc_insertion_point(field_get:mode.InsertRequest.into)
  return _internal_into();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertRequest::set_into(ArgT0&& arg0, ArgT... args) {
 
 into_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mode.InsertRequest.into)
}
inline std::string* InsertRequest::mutable_into() {
  std::string* _s = _internal_mutable_into();
  // @@protoc_insertion_point(field_mutable:mode.InsertRequest.into)
  return _s;
}
inline const std::string& InsertRequest::_internal_into() const {
  return into_.Get();
}
inline void InsertRequest::_internal_set_into(const std::string& value) {
  
  into_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InsertRequest::_internal_mutable_into() {
  
  return into_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InsertRequest::release_into() {
  // @@protoc_insertion_point(field_release:mode.InsertRequest.into)
  return into_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InsertRequest::set_allocated_into(std::string* into) {
  if (into != nullptr) {
    
  } else {
    
  }
  into_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), into,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (into_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    into_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mode.InsertRequest.into)
}

// map<string, string> row = 3;
inline int InsertRequest::_internal_row_size() const {
  return row_.size();
}
inline int InsertRequest::row_size() const {
  return _internal_row_size();
}
inline void InsertRequest::clear_row() {
  row_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
InsertRequest::_internal_row() const {
  return row_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
InsertRequest::row() const {
  // @@protoc_insertion_point(field_map:mode.InsertRequest.row)
  return _internal_row();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
InsertRequest::_internal_mutable_row() {
  return row_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
InsertRequest::mutable_row() {
  // @@protoc_insertion_point(field_mutable_map:mode.InsertRequest.row)
  return _internal_mutable_row();
}

// -------------------------------------------------------------------

// CreateRequest

// string name = 1;
inline void CreateRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateRequest::name() const {
  // @@protoc_insertion_point(field_get:mode.CreateRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mode.CreateRequest.name)
}
inline std::string* CreateRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mode.CreateRequest.name)
  return _s;
}
inline const std::string& CreateRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateRequest::release_name() {
  // @@protoc_insertion_point(field_release:mode.CreateRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mode.CreateRequest.name)
}

// -------------------------------------------------------------------

// FindRequestOptions

// bool compressed = 1;
inline void FindRequestOptions::clear_compressed() {
  compressed_ = false;
}
inline bool FindRequestOptions::_internal_compressed() const {
  return compressed_;
}
inline bool FindRequestOptions::compressed() const {
  // @@protoc_insertion_point(field_get:mode.FindRequestOptions.compressed)
  return _internal_compressed();
}
inline void FindRequestOptions::_internal_set_compressed(bool value) {
  
  compressed_ = value;
}
inline void FindRequestOptions::set_compressed(bool value) {
  _internal_set_compressed(value);
  // @@protoc_insertion_point(field_set:mode.FindRequestOptions.compressed)
}

// bool group = 2;
inline void FindRequestOptions::clear_group() {
  group_ = false;
}
inline bool FindRequestOptions::_internal_group() const {
  return group_;
}
inline bool FindRequestOptions::group() const {
  // @@protoc_insertion_point(field_get:mode.FindRequestOptions.group)
  return _internal_group();
}
inline void FindRequestOptions::_internal_set_group(bool value) {
  
  group_ = value;
}
inline void FindRequestOptions::set_group(bool value) {
  _internal_set_group(value);
  // @@protoc_insertion_point(field_set:mode.FindRequestOptions.group)
}

// bool negate = 3;
inline void FindRequestOptions::clear_negate() {
  negate_ = false;
}
inline bool FindRequestOptions::_internal_negate() const {
  return negate_;
}
inline bool FindRequestOptions::negate() const {
  // @@protoc_insertion_point(field_get:mode.FindRequestOptions.negate)
  return _internal_negate();
}
inline void FindRequestOptions::_internal_set_negate(bool value) {
  
  negate_ = value;
}
inline void FindRequestOptions::set_negate(bool value) {
  _internal_set_negate(value);
  // @@protoc_insertion_point(field_set:mode.FindRequestOptions.negate)
}

// -------------------------------------------------------------------

// Field

// string table_name = 1;
inline void Field::clear_table_name() {
  table_name_.ClearToEmpty();
}
inline const std::string& Field::table_name() const {
  // @@protoc_insertion_point(field_get:mode.Field.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Field::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mode.Field.table_name)
}
inline std::string* Field::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:mode.Field.table_name)
  return _s;
}
inline const std::string& Field::_internal_table_name() const {
  return table_name_.Get();
}
inline void Field::_internal_set_table_name(const std::string& value) {
  
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Field::_internal_mutable_table_name() {
  
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Field::release_table_name() {
  // @@protoc_insertion_point(field_release:mode.Field.table_name)
  return table_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Field::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (table_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    table_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mode.Field.table_name)
}

// string table_field = 2;
inline void Field::clear_table_field() {
  table_field_.ClearToEmpty();
}
inline const std::string& Field::table_field() const {
  // @@protoc_insertion_point(field_get:mode.Field.table_field)
  return _internal_table_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Field::set_table_field(ArgT0&& arg0, ArgT... args) {
 
 table_field_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mode.Field.table_field)
}
inline std::string* Field::mutable_table_field() {
  std::string* _s = _internal_mutable_table_field();
  // @@protoc_insertion_point(field_mutable:mode.Field.table_field)
  return _s;
}
inline const std::string& Field::_internal_table_field() const {
  return table_field_.Get();
}
inline void Field::_internal_set_table_field(const std::string& value) {
  
  table_field_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Field::_internal_mutable_table_field() {
  
  return table_field_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Field::release_table_field() {
  // @@protoc_insertion_point(field_release:mode.Field.table_field)
  return table_field_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Field::set_allocated_table_field(std::string* table_field) {
  if (table_field != nullptr) {
    
  } else {
    
  }
  table_field_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_field,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (table_field_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    table_field_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mode.Field.table_field)
}

// -------------------------------------------------------------------

// FieldPair

// .mode.Field field1 = 1;
inline bool FieldPair::_internal_has_field1() const {
  return this != internal_default_instance() && field1_ != nullptr;
}
inline bool FieldPair::has_field1() const {
  return _internal_has_field1();
}
inline void FieldPair::clear_field1() {
  if (GetArenaForAllocation() == nullptr && field1_ != nullptr) {
    delete field1_;
  }
  field1_ = nullptr;
}
inline const ::mode::Field& FieldPair::_internal_field1() const {
  const ::mode::Field* p = field1_;
  return p != nullptr ? *p : reinterpret_cast<const ::mode::Field&>(
      ::mode::_Field_default_instance_);
}
inline const ::mode::Field& FieldPair::field1() const {
  // @@protoc_insertion_point(field_get:mode.FieldPair.field1)
  return _internal_field1();
}
inline void FieldPair::unsafe_arena_set_allocated_field1(
    ::mode::Field* field1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(field1_);
  }
  field1_ = field1;
  if (field1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mode.FieldPair.field1)
}
inline ::mode::Field* FieldPair::release_field1() {
  
  ::mode::Field* temp = field1_;
  field1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mode::Field* FieldPair::unsafe_arena_release_field1() {
  // @@protoc_insertion_point(field_release:mode.FieldPair.field1)
  
  ::mode::Field* temp = field1_;
  field1_ = nullptr;
  return temp;
}
inline ::mode::Field* FieldPair::_internal_mutable_field1() {
  
  if (field1_ == nullptr) {
    auto* p = CreateMaybeMessage<::mode::Field>(GetArenaForAllocation());
    field1_ = p;
  }
  return field1_;
}
inline ::mode::Field* FieldPair::mutable_field1() {
  ::mode::Field* _msg = _internal_mutable_field1();
  // @@protoc_insertion_point(field_mutable:mode.FieldPair.field1)
  return _msg;
}
inline void FieldPair::set_allocated_field1(::mode::Field* field1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete field1_;
  }
  if (field1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mode::Field>::GetOwningArena(field1);
    if (message_arena != submessage_arena) {
      field1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, field1, submessage_arena);
    }
    
  } else {
    
  }
  field1_ = field1;
  // @@protoc_insertion_point(field_set_allocated:mode.FieldPair.field1)
}

// .mode.Field field2 = 2;
inline bool FieldPair::_internal_has_field2() const {
  return this != internal_default_instance() && field2_ != nullptr;
}
inline bool FieldPair::has_field2() const {
  return _internal_has_field2();
}
inline void FieldPair::clear_field2() {
  if (GetArenaForAllocation() == nullptr && field2_ != nullptr) {
    delete field2_;
  }
  field2_ = nullptr;
}
inline const ::mode::Field& FieldPair::_internal_field2() const {
  const ::mode::Field* p = field2_;
  return p != nullptr ? *p : reinterpret_cast<const ::mode::Field&>(
      ::mode::_Field_default_instance_);
}
inline const ::mode::Field& FieldPair::field2() const {
  // @@protoc_insertion_point(field_get:mode.FieldPair.field2)
  return _internal_field2();
}
inline void FieldPair::unsafe_arena_set_allocated_field2(
    ::mode::Field* field2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(field2_);
  }
  field2_ = field2;
  if (field2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mode.FieldPair.field2)
}
inline ::mode::Field* FieldPair::release_field2() {
  
  ::mode::Field* temp = field2_;
  field2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mode::Field* FieldPair::unsafe_arena_release_field2() {
  // @@protoc_insertion_point(field_release:mode.FieldPair.field2)
  
  ::mode::Field* temp = field2_;
  field2_ = nullptr;
  return temp;
}
inline ::mode::Field* FieldPair::_internal_mutable_field2() {
  
  if (field2_ == nullptr) {
    auto* p = CreateMaybeMessage<::mode::Field>(GetArenaForAllocation());
    field2_ = p;
  }
  return field2_;
}
inline ::mode::Field* FieldPair::mutable_field2() {
  ::mode::Field* _msg = _internal_mutable_field2();
  // @@protoc_insertion_point(field_mutable:mode.FieldPair.field2)
  return _msg;
}
inline void FieldPair::set_allocated_field2(::mode::Field* field2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete field2_;
  }
  if (field2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mode::Field>::GetOwningArena(field2);
    if (message_arena != submessage_arena) {
      field2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, field2, submessage_arena);
    }
    
  } else {
    
  }
  field2_ = field2;
  // @@protoc_insertion_point(field_set_allocated:mode.FieldPair.field2)
}

// -------------------------------------------------------------------

// ProjectedField

// .mode.Field field = 1;
inline bool ProjectedField::_internal_has_field() const {
  return this != internal_default_instance() && field_ != nullptr;
}
inline bool ProjectedField::has_field() const {
  return _internal_has_field();
}
inline void ProjectedField::clear_field() {
  if (GetArenaForAllocation() == nullptr && field_ != nullptr) {
    delete field_;
  }
  field_ = nullptr;
}
inline const ::mode::Field& ProjectedField::_internal_field() const {
  const ::mode::Field* p = field_;
  return p != nullptr ? *p : reinterpret_cast<const ::mode::Field&>(
      ::mode::_Field_default_instance_);
}
inline const ::mode::Field& ProjectedField::field() const {
  // @@protoc_insertion_point(field_get:mode.ProjectedField.field)
  return _internal_field();
}
inline void ProjectedField::unsafe_arena_set_allocated_field(
    ::mode::Field* field) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(field_);
  }
  field_ = field;
  if (field) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mode.ProjectedField.field)
}
inline ::mode::Field* ProjectedField::release_field() {
  
  ::mode::Field* temp = field_;
  field_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mode::Field* ProjectedField::unsafe_arena_release_field() {
  // @@protoc_insertion_point(field_release:mode.ProjectedField.field)
  
  ::mode::Field* temp = field_;
  field_ = nullptr;
  return temp;
}
inline ::mode::Field* ProjectedField::_internal_mutable_field() {
  
  if (field_ == nullptr) {
    auto* p = CreateMaybeMessage<::mode::Field>(GetArenaForAllocation());
    field_ = p;
  }
  return field_;
}
inline ::mode::Field* ProjectedField::mutable_field() {
  ::mode::Field* _msg = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:mode.ProjectedField.field)
  return _msg;
}
inline void ProjectedField::set_allocated_field(::mode::Field* field) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete field_;
  }
  if (field) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mode::Field>::GetOwningArena(field);
    if (message_arena != submessage_arena) {
      field = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, field, submessage_arena);
    }
    
  } else {
    
  }
  field_ = field;
  // @@protoc_insertion_point(field_set_allocated:mode.ProjectedField.field)
}

// optional string rename = 2;
inline bool ProjectedField::_internal_has_rename() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProjectedField::has_rename() const {
  return _internal_has_rename();
}
inline void ProjectedField::clear_rename() {
  rename_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProjectedField::rename() const {
  // @@protoc_insertion_point(field_get:mode.ProjectedField.rename)
  return _internal_rename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProjectedField::set_rename(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 rename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mode.ProjectedField.rename)
}
inline std::string* ProjectedField::mutable_rename() {
  std::string* _s = _internal_mutable_rename();
  // @@protoc_insertion_point(field_mutable:mode.ProjectedField.rename)
  return _s;
}
inline const std::string& ProjectedField::_internal_rename() const {
  return rename_.Get();
}
inline void ProjectedField::_internal_set_rename(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  rename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProjectedField::_internal_mutable_rename() {
  _has_bits_[0] |= 0x00000001u;
  return rename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProjectedField::release_rename() {
  // @@protoc_insertion_point(field_release:mode.ProjectedField.rename)
  if (!_internal_has_rename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = rename_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    rename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProjectedField::set_allocated_rename(std::string* rename) {
  if (rename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  rename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    rename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mode.ProjectedField.rename)
}

// -------------------------------------------------------------------

// Filter

// .mode.Field field = 1;
inline bool Filter::_internal_has_field() const {
  return this != internal_default_instance() && field_ != nullptr;
}
inline bool Filter::has_field() const {
  return _internal_has_field();
}
inline void Filter::clear_field() {
  if (GetArenaForAllocation() == nullptr && field_ != nullptr) {
    delete field_;
  }
  field_ = nullptr;
}
inline const ::mode::Field& Filter::_internal_field() const {
  const ::mode::Field* p = field_;
  return p != nullptr ? *p : reinterpret_cast<const ::mode::Field&>(
      ::mode::_Field_default_instance_);
}
inline const ::mode::Field& Filter::field() const {
  // @@protoc_insertion_point(field_get:mode.Filter.field)
  return _internal_field();
}
inline void Filter::unsafe_arena_set_allocated_field(
    ::mode::Field* field) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(field_);
  }
  field_ = field;
  if (field) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mode.Filter.field)
}
inline ::mode::Field* Filter::release_field() {
  
  ::mode::Field* temp = field_;
  field_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mode::Field* Filter::unsafe_arena_release_field() {
  // @@protoc_insertion_point(field_release:mode.Filter.field)
  
  ::mode::Field* temp = field_;
  field_ = nullptr;
  return temp;
}
inline ::mode::Field* Filter::_internal_mutable_field() {
  
  if (field_ == nullptr) {
    auto* p = CreateMaybeMessage<::mode::Field>(GetArenaForAllocation());
    field_ = p;
  }
  return field_;
}
inline ::mode::Field* Filter::mutable_field() {
  ::mode::Field* _msg = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:mode.Filter.field)
  return _msg;
}
inline void Filter::set_allocated_field(::mode::Field* field) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete field_;
  }
  if (field) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mode::Field>::GetOwningArena(field);
    if (message_arena != submessage_arena) {
      field = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, field, submessage_arena);
    }
    
  } else {
    
  }
  field_ = field;
  // @@protoc_insertion_point(field_set_allocated:mode.Filter.field)
}

// string operator = 2;
inline void Filter::clear_operator_() {
  operator__.ClearToEmpty();
}
inline const std::string& Filter::operator_() const {
  // @@protoc_insertion_point(field_get:mode.Filter.operator)
  return _internal_operator_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Filter::set_operator_(ArgT0&& arg0, ArgT... args) {
 
 operator__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mode.Filter.operator)
}
inline std::string* Filter::mutable_operator_() {
  std::string* _s = _internal_mutable_operator_();
  // @@protoc_insertion_point(field_mutable:mode.Filter.operator)
  return _s;
}
inline const std::string& Filter::_internal_operator_() const {
  return operator__.Get();
}
inline void Filter::_internal_set_operator_(const std::string& value) {
  
  operator__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Filter::_internal_mutable_operator_() {
  
  return operator__.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Filter::release_operator_() {
  // @@protoc_insertion_point(field_release:mode.Filter.operator)
  return operator__.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Filter::set_allocated_operator_(std::string* operator_) {
  if (operator_ != nullptr) {
    
  } else {
    
  }
  operator__.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), operator_,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (operator__.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    operator__.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mode.Filter.operator)
}

// string value = 3;
inline void Filter::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& Filter::value() const {
  // @@protoc_insertion_point(field_get:mode.Filter.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Filter::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mode.Filter.value)
}
inline std::string* Filter::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:mode.Filter.value)
  return _s;
}
inline const std::string& Filter::_internal_value() const {
  return value_.Get();
}
inline void Filter::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Filter::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Filter::release_value() {
  // @@protoc_insertion_point(field_release:mode.Filter.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Filter::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mode.Filter.value)
}

// string function = 4;
inline void Filter::clear_function() {
  function_.ClearToEmpty();
}
inline const std::string& Filter::function() const {
  // @@protoc_insertion_point(field_get:mode.Filter.function)
  return _internal_function();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Filter::set_function(ArgT0&& arg0, ArgT... args) {
 
 function_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mode.Filter.function)
}
inline std::string* Filter::mutable_function() {
  std::string* _s = _internal_mutable_function();
  // @@protoc_insertion_point(field_mutable:mode.Filter.function)
  return _s;
}
inline const std::string& Filter::_internal_function() const {
  return function_.Get();
}
inline void Filter::_internal_set_function(const std::string& value) {
  
  function_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Filter::_internal_mutable_function() {
  
  return function_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Filter::release_function() {
  // @@protoc_insertion_point(field_release:mode.Filter.function)
  return function_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Filter::set_allocated_function(std::string* function) {
  if (function != nullptr) {
    
  } else {
    
  }
  function_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), function,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (function_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    function_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mode.Filter.function)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mode

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mode_2eproto
