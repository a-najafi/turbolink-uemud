//Generated by TurboLink CodeGenerator, do not edit!
#include "EcsRelayContext.h"
#include "SEcsrelay/EcsRelayClient.h"
#include "EcsRelayService_Private.h"
#include "EcsRelayMarshaling.h"
#include "TurboLinkGrpcManager.h"

GrpcContext_ECSRelayService_Authenticate::GrpcContext_ECSRelayService_Authenticate(FGrpcContextHandle _Handle, UGrpcService* _Service, UGrpcClient* _Client)
	: Super(_Handle, _Service, _Client)
{
}

void GrpcContext_ECSRelayService_Authenticate::Call(const FGrpcEcsrelaySignature& Request)
{
	check(GetState() == EGrpcContextState::Ready);
	UpdateState(EGrpcContextState::Initialing);

	::ecsrelay::Signature rpcRequest;
	TURBOLINK_TO_GRPC(&Request, &rpcRequest);

	UECSRelayService* service = (UECSRelayService*)Service;
	RpcReaderWriter = service->d->Stub->AsyncAuthenticate(RpcContext.get(), rpcRequest, service->TurboLinkManager->d->CompletionQueue.get());
	RpcReaderWriter->ReadInitialMetadata(InitialTag);
}

void GrpcContext_ECSRelayService_Authenticate::OnRpcEvent(bool Ok, const void* EventTag)
{
	Super::OnRpcEventInternal(Ok, EventTag, [this](const FGrpcResult& _Result, ::ecsrelay::Identity* _RpcResponse) {
		UECSRelayServiceClient* client = (UECSRelayServiceClient*)(this->Client);
		if (!(client->OnAuthenticateResponse.IsBound())) return;

		FGrpcEcsrelayIdentity response;
		if (_RpcResponse) {
			GRPC_TO_TURBOLINK(_RpcResponse, &response);
		}
		client->OnAuthenticateResponse.Broadcast(Handle, _Result, response);
	});
}

GrpcContext_ECSRelayService_Revoke::GrpcContext_ECSRelayService_Revoke(FGrpcContextHandle _Handle, UGrpcService* _Service, UGrpcClient* _Client)
	: Super(_Handle, _Service, _Client)
{
}

void GrpcContext_ECSRelayService_Revoke::Call(const FGrpcEcsrelaySignature& Request)
{
	check(GetState() == EGrpcContextState::Ready);
	UpdateState(EGrpcContextState::Initialing);

	::ecsrelay::Signature rpcRequest;
	TURBOLINK_TO_GRPC(&Request, &rpcRequest);

	UECSRelayService* service = (UECSRelayService*)Service;
	RpcReaderWriter = service->d->Stub->AsyncRevoke(RpcContext.get(), rpcRequest, service->TurboLinkManager->d->CompletionQueue.get());
	RpcReaderWriter->ReadInitialMetadata(InitialTag);
}

void GrpcContext_ECSRelayService_Revoke::OnRpcEvent(bool Ok, const void* EventTag)
{
	Super::OnRpcEventInternal(Ok, EventTag, [this](const FGrpcResult& _Result, ::ecsrelay::Identity* _RpcResponse) {
		UECSRelayServiceClient* client = (UECSRelayServiceClient*)(this->Client);
		if (!(client->OnRevokeResponse.IsBound())) return;

		FGrpcEcsrelayIdentity response;
		if (_RpcResponse) {
			GRPC_TO_TURBOLINK(_RpcResponse, &response);
		}
		client->OnRevokeResponse.Broadcast(Handle, _Result, response);
	});
}

GrpcContext_ECSRelayService_Ping::GrpcContext_ECSRelayService_Ping(FGrpcContextHandle _Handle, UGrpcService* _Service, UGrpcClient* _Client)
	: Super(_Handle, _Service, _Client)
{
}

void GrpcContext_ECSRelayService_Ping::Call(const FGrpcEcsrelaySignature& Request)
{
	check(GetState() == EGrpcContextState::Ready);
	UpdateState(EGrpcContextState::Initialing);

	::ecsrelay::Signature rpcRequest;
	TURBOLINK_TO_GRPC(&Request, &rpcRequest);

	UECSRelayService* service = (UECSRelayService*)Service;
	RpcReaderWriter = service->d->Stub->AsyncPing(RpcContext.get(), rpcRequest, service->TurboLinkManager->d->CompletionQueue.get());
	RpcReaderWriter->ReadInitialMetadata(InitialTag);
}

void GrpcContext_ECSRelayService_Ping::OnRpcEvent(bool Ok, const void* EventTag)
{
	Super::OnRpcEventInternal(Ok, EventTag, [this](const FGrpcResult& _Result, ::ecsrelay::Identity* _RpcResponse) {
		UECSRelayServiceClient* client = (UECSRelayServiceClient*)(this->Client);
		if (!(client->OnPingResponse.IsBound())) return;

		FGrpcEcsrelayIdentity response;
		if (_RpcResponse) {
			GRPC_TO_TURBOLINK(_RpcResponse, &response);
		}
		client->OnPingResponse.Broadcast(Handle, _Result, response);
	});
}

GrpcContext_ECSRelayService_CountAuthenticated::GrpcContext_ECSRelayService_CountAuthenticated(FGrpcContextHandle _Handle, UGrpcService* _Service, UGrpcClient* _Client)
	: Super(_Handle, _Service, _Client)
{
}

void GrpcContext_ECSRelayService_CountAuthenticated::Call(const FGrpcEcsrelayCountIdentitiesRequest& Request)
{
	check(GetState() == EGrpcContextState::Ready);
	UpdateState(EGrpcContextState::Initialing);

	::ecsrelay::CountIdentitiesRequest rpcRequest;
	TURBOLINK_TO_GRPC(&Request, &rpcRequest);

	UECSRelayService* service = (UECSRelayService*)Service;
	RpcReaderWriter = service->d->Stub->AsyncCountAuthenticated(RpcContext.get(), rpcRequest, service->TurboLinkManager->d->CompletionQueue.get());
	RpcReaderWriter->ReadInitialMetadata(InitialTag);
}

void GrpcContext_ECSRelayService_CountAuthenticated::OnRpcEvent(bool Ok, const void* EventTag)
{
	Super::OnRpcEventInternal(Ok, EventTag, [this](const FGrpcResult& _Result, ::ecsrelay::CountIdentitiesResponse* _RpcResponse) {
		UECSRelayServiceClient* client = (UECSRelayServiceClient*)(this->Client);
		if (!(client->OnCountAuthenticatedResponse.IsBound())) return;

		FGrpcEcsrelayCountIdentitiesResponse response;
		if (_RpcResponse) {
			GRPC_TO_TURBOLINK(_RpcResponse, &response);
		}
		client->OnCountAuthenticatedResponse.Broadcast(Handle, _Result, response);
	});
}

GrpcContext_ECSRelayService_CountConnected::GrpcContext_ECSRelayService_CountConnected(FGrpcContextHandle _Handle, UGrpcService* _Service, UGrpcClient* _Client)
	: Super(_Handle, _Service, _Client)
{
}

void GrpcContext_ECSRelayService_CountConnected::Call(const FGrpcEcsrelayCountIdentitiesRequest& Request)
{
	check(GetState() == EGrpcContextState::Ready);
	UpdateState(EGrpcContextState::Initialing);

	::ecsrelay::CountIdentitiesRequest rpcRequest;
	TURBOLINK_TO_GRPC(&Request, &rpcRequest);

	UECSRelayService* service = (UECSRelayService*)Service;
	RpcReaderWriter = service->d->Stub->AsyncCountConnected(RpcContext.get(), rpcRequest, service->TurboLinkManager->d->CompletionQueue.get());
	RpcReaderWriter->ReadInitialMetadata(InitialTag);
}

void GrpcContext_ECSRelayService_CountConnected::OnRpcEvent(bool Ok, const void* EventTag)
{
	Super::OnRpcEventInternal(Ok, EventTag, [this](const FGrpcResult& _Result, ::ecsrelay::CountIdentitiesResponse* _RpcResponse) {
		UECSRelayServiceClient* client = (UECSRelayServiceClient*)(this->Client);
		if (!(client->OnCountConnectedResponse.IsBound())) return;

		FGrpcEcsrelayCountIdentitiesResponse response;
		if (_RpcResponse) {
			GRPC_TO_TURBOLINK(_RpcResponse, &response);
		}
		client->OnCountConnectedResponse.Broadcast(Handle, _Result, response);
	});
}

GrpcContext_ECSRelayService_Subscribe::GrpcContext_ECSRelayService_Subscribe(FGrpcContextHandle _Handle, UGrpcService* _Service, UGrpcClient* _Client)
	: Super(_Handle, _Service, _Client)
{
}

void GrpcContext_ECSRelayService_Subscribe::Call(const FGrpcEcsrelaySubscriptionRequest& Request)
{
	check(GetState() == EGrpcContextState::Ready);
	UpdateState(EGrpcContextState::Initialing);

	::ecsrelay::SubscriptionRequest rpcRequest;
	TURBOLINK_TO_GRPC(&Request, &rpcRequest);

	UECSRelayService* service = (UECSRelayService*)Service;
	RpcReaderWriter = service->d->Stub->AsyncSubscribe(RpcContext.get(), rpcRequest, service->TurboLinkManager->d->CompletionQueue.get());
	RpcReaderWriter->ReadInitialMetadata(InitialTag);
}

void GrpcContext_ECSRelayService_Subscribe::OnRpcEvent(bool Ok, const void* EventTag)
{
	Super::OnRpcEventInternal(Ok, EventTag, [this](const FGrpcResult& _Result, ::ecsrelay::Subscription* _RpcResponse) {
		UECSRelayServiceClient* client = (UECSRelayServiceClient*)(this->Client);
		if (!(client->OnSubscribeResponse.IsBound())) return;

		FGrpcEcsrelaySubscription response;
		if (_RpcResponse) {
			GRPC_TO_TURBOLINK(_RpcResponse, &response);
		}
		client->OnSubscribeResponse.Broadcast(Handle, _Result, response);
	});
}

GrpcContext_ECSRelayService_Unsubscribe::GrpcContext_ECSRelayService_Unsubscribe(FGrpcContextHandle _Handle, UGrpcService* _Service, UGrpcClient* _Client)
	: Super(_Handle, _Service, _Client)
{
}

void GrpcContext_ECSRelayService_Unsubscribe::Call(const FGrpcEcsrelaySubscriptionRequest& Request)
{
	check(GetState() == EGrpcContextState::Ready);
	UpdateState(EGrpcContextState::Initialing);

	::ecsrelay::SubscriptionRequest rpcRequest;
	TURBOLINK_TO_GRPC(&Request, &rpcRequest);

	UECSRelayService* service = (UECSRelayService*)Service;
	RpcReaderWriter = service->d->Stub->AsyncUnsubscribe(RpcContext.get(), rpcRequest, service->TurboLinkManager->d->CompletionQueue.get());
	RpcReaderWriter->ReadInitialMetadata(InitialTag);
}

void GrpcContext_ECSRelayService_Unsubscribe::OnRpcEvent(bool Ok, const void* EventTag)
{
	Super::OnRpcEventInternal(Ok, EventTag, [this](const FGrpcResult& _Result, ::ecsrelay::Subscription* _RpcResponse) {
		UECSRelayServiceClient* client = (UECSRelayServiceClient*)(this->Client);
		if (!(client->OnUnsubscribeResponse.IsBound())) return;

		FGrpcEcsrelaySubscription response;
		if (_RpcResponse) {
			GRPC_TO_TURBOLINK(_RpcResponse, &response);
		}
		client->OnUnsubscribeResponse.Broadcast(Handle, _Result, response);
	});
}

GrpcContext_ECSRelayService_OpenStream::GrpcContext_ECSRelayService_OpenStream(FGrpcContextHandle _Handle, UGrpcService* _Service, UGrpcClient* _Client)
	: Super(_Handle, _Service, _Client)
{
}

void GrpcContext_ECSRelayService_OpenStream::Call(const FGrpcEcsrelaySignature& Request)
{
	check(GetState() == EGrpcContextState::Ready);
	UpdateState(EGrpcContextState::Initialing);

	::ecsrelay::Signature rpcRequest;
	TURBOLINK_TO_GRPC(&Request, &rpcRequest);

	UECSRelayService* service = (UECSRelayService*)Service;
	RpcReaderWriter = service->d->Stub->AsyncOpenStream(RpcContext.get(), rpcRequest, service->TurboLinkManager->d->CompletionQueue.get(), InitialTag);
}

void GrpcContext_ECSRelayService_OpenStream::OnRpcEvent(bool Ok, const void* EventTag)
{
	Super::OnRpcEventInternal(Ok, EventTag, [this](const FGrpcResult& _Result, ::ecsrelay::Message* _RpcResponse) {
		UECSRelayServiceClient* client = (UECSRelayServiceClient*)(this->Client);
		if (!(client->OnOpenStreamResponse.IsBound())) return;

		FGrpcEcsrelayMessage response;
		if (_RpcResponse) {
			GRPC_TO_TURBOLINK(_RpcResponse, &response);
		}
		client->OnOpenStreamResponse.Broadcast(Handle, _Result, response);
	});
}

GrpcContext_ECSRelayService_PushStream::GrpcContext_ECSRelayService_PushStream(FGrpcContextHandle _Handle, UGrpcService* _Service, UGrpcClient* _Client)
	: Super(_Handle, _Service, _Client)
{
}

void GrpcContext_ECSRelayService_PushStream::Init()
{
	check(GetState() == EGrpcContextState::Ready);
	UpdateState(EGrpcContextState::Initialing);

	UECSRelayService* service = (UECSRelayService*)Service;
	RpcReaderWriter = service->d->Stub->AsyncPushStream(RpcContext.get(), service->TurboLinkManager->d->CompletionQueue.get(), InitialTag);
}

void GrpcContext_ECSRelayService_PushStream::Call(const FGrpcEcsrelayPushRequest& Request)
{
	::ecsrelay::PushRequest rpcRequest;
	TURBOLINK_TO_GRPC(&Request, &rpcRequest);

	if (CanSend) {
		RpcReaderWriter->Write(rpcRequest, WriteTag);
		CanSend = false;
	}
	else {
		SendQueue.push_back(rpcRequest);
	}
}

void GrpcContext_ECSRelayService_PushStream::OnRpcEvent(bool Ok, const void* EventTag)
{
	Super::OnRpcEventInternal(Ok, EventTag, [this](const FGrpcResult& _Result, ::ecsrelay::PushResponse* _RpcResponse) {
		UECSRelayServiceClient* client = (UECSRelayServiceClient*)(this->Client);
		if (!(client->OnPushStreamResponse.IsBound())) return;

		FGrpcEcsrelayPushResponse response;
		if (_RpcResponse) {
			GRPC_TO_TURBOLINK(_RpcResponse, &response);
		}
		client->OnPushStreamResponse.Broadcast(Handle, _Result, response);
	});
}

GrpcContext_ECSRelayService_Push::GrpcContext_ECSRelayService_Push(FGrpcContextHandle _Handle, UGrpcService* _Service, UGrpcClient* _Client)
	: Super(_Handle, _Service, _Client)
{
}

void GrpcContext_ECSRelayService_Push::Call(const FGrpcEcsrelayPushRequest& Request)
{
	check(GetState() == EGrpcContextState::Ready);
	UpdateState(EGrpcContextState::Initialing);

	::ecsrelay::PushRequest rpcRequest;
	TURBOLINK_TO_GRPC(&Request, &rpcRequest);

	UECSRelayService* service = (UECSRelayService*)Service;
	RpcReaderWriter = service->d->Stub->AsyncPush(RpcContext.get(), rpcRequest, service->TurboLinkManager->d->CompletionQueue.get());
	RpcReaderWriter->ReadInitialMetadata(InitialTag);
}

void GrpcContext_ECSRelayService_Push::OnRpcEvent(bool Ok, const void* EventTag)
{
	Super::OnRpcEventInternal(Ok, EventTag, [this](const FGrpcResult& _Result, ::ecsrelay::PushResponse* _RpcResponse) {
		UECSRelayServiceClient* client = (UECSRelayServiceClient*)(this->Client);
		if (!(client->OnPushResponse.IsBound())) return;

		FGrpcEcsrelayPushResponse response;
		if (_RpcResponse) {
			GRPC_TO_TURBOLINK(_RpcResponse, &response);
		}
		client->OnPushResponse.Broadcast(Handle, _Result, response);
	});
}

GrpcContext_ECSRelayService_MinBalanceForPush::GrpcContext_ECSRelayService_MinBalanceForPush(FGrpcContextHandle _Handle, UGrpcService* _Service, UGrpcClient* _Client)
	: Super(_Handle, _Service, _Client)
{
}

void GrpcContext_ECSRelayService_MinBalanceForPush::Call(const FGrpcEcsrelayBalanceRequest& Request)
{
	check(GetState() == EGrpcContextState::Ready);
	UpdateState(EGrpcContextState::Initialing);

	::ecsrelay::BalanceRequest rpcRequest;
	TURBOLINK_TO_GRPC(&Request, &rpcRequest);

	UECSRelayService* service = (UECSRelayService*)Service;
	RpcReaderWriter = service->d->Stub->AsyncMinBalanceForPush(RpcContext.get(), rpcRequest, service->TurboLinkManager->d->CompletionQueue.get());
	RpcReaderWriter->ReadInitialMetadata(InitialTag);
}

void GrpcContext_ECSRelayService_MinBalanceForPush::OnRpcEvent(bool Ok, const void* EventTag)
{
	Super::OnRpcEventInternal(Ok, EventTag, [this](const FGrpcResult& _Result, ::ecsrelay::BalanceResponse* _RpcResponse) {
		UECSRelayServiceClient* client = (UECSRelayServiceClient*)(this->Client);
		if (!(client->OnMinBalanceForPushResponse.IsBound())) return;

		FGrpcEcsrelayBalanceResponse response;
		if (_RpcResponse) {
			GRPC_TO_TURBOLINK(_RpcResponse, &response);
		}
		client->OnMinBalanceForPushResponse.Broadcast(Handle, _Result, response);
	});
}
