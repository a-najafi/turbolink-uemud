#if defined(_MSC_VER)
  #pragma warning (disable:4946) // reinterpret_cast used between related classes: 'class1' and 'class2'
  #pragma warning (disable:4800) // 'type' : forcing value to bool 'true' or 'false' (performance warning)
#endif
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ecs_relay.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ecs_5frelay_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ecs_5frelay_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ecs_5frelay_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ecs_5frelay_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ecs_5frelay_2eproto;
namespace ecsrelay {
class BalanceRequest;
struct BalanceRequestDefaultTypeInternal;
extern BalanceRequestDefaultTypeInternal _BalanceRequest_default_instance_;
class BalanceResponse;
struct BalanceResponseDefaultTypeInternal;
extern BalanceResponseDefaultTypeInternal _BalanceResponse_default_instance_;
class CountIdentitiesRequest;
struct CountIdentitiesRequestDefaultTypeInternal;
extern CountIdentitiesRequestDefaultTypeInternal _CountIdentitiesRequest_default_instance_;
class CountIdentitiesResponse;
struct CountIdentitiesResponseDefaultTypeInternal;
extern CountIdentitiesResponseDefaultTypeInternal _CountIdentitiesResponse_default_instance_;
class Identity;
struct IdentityDefaultTypeInternal;
extern IdentityDefaultTypeInternal _Identity_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class PushManyRequest;
struct PushManyRequestDefaultTypeInternal;
extern PushManyRequestDefaultTypeInternal _PushManyRequest_default_instance_;
class PushRequest;
struct PushRequestDefaultTypeInternal;
extern PushRequestDefaultTypeInternal _PushRequest_default_instance_;
class PushResponse;
struct PushResponseDefaultTypeInternal;
extern PushResponseDefaultTypeInternal _PushResponse_default_instance_;
class Signature;
struct SignatureDefaultTypeInternal;
extern SignatureDefaultTypeInternal _Signature_default_instance_;
class Subscription;
struct SubscriptionDefaultTypeInternal;
extern SubscriptionDefaultTypeInternal _Subscription_default_instance_;
class SubscriptionRequest;
struct SubscriptionRequestDefaultTypeInternal;
extern SubscriptionRequestDefaultTypeInternal _SubscriptionRequest_default_instance_;
}  // namespace ecsrelay
PROTOBUF_NAMESPACE_OPEN
template<> ::ecsrelay::BalanceRequest* Arena::CreateMaybeMessage<::ecsrelay::BalanceRequest>(Arena*);
template<> ::ecsrelay::BalanceResponse* Arena::CreateMaybeMessage<::ecsrelay::BalanceResponse>(Arena*);
template<> ::ecsrelay::CountIdentitiesRequest* Arena::CreateMaybeMessage<::ecsrelay::CountIdentitiesRequest>(Arena*);
template<> ::ecsrelay::CountIdentitiesResponse* Arena::CreateMaybeMessage<::ecsrelay::CountIdentitiesResponse>(Arena*);
template<> ::ecsrelay::Identity* Arena::CreateMaybeMessage<::ecsrelay::Identity>(Arena*);
template<> ::ecsrelay::Message* Arena::CreateMaybeMessage<::ecsrelay::Message>(Arena*);
template<> ::ecsrelay::PushManyRequest* Arena::CreateMaybeMessage<::ecsrelay::PushManyRequest>(Arena*);
template<> ::ecsrelay::PushRequest* Arena::CreateMaybeMessage<::ecsrelay::PushRequest>(Arena*);
template<> ::ecsrelay::PushResponse* Arena::CreateMaybeMessage<::ecsrelay::PushResponse>(Arena*);
template<> ::ecsrelay::Signature* Arena::CreateMaybeMessage<::ecsrelay::Signature>(Arena*);
template<> ::ecsrelay::Subscription* Arena::CreateMaybeMessage<::ecsrelay::Subscription>(Arena*);
template<> ::ecsrelay::SubscriptionRequest* Arena::CreateMaybeMessage<::ecsrelay::SubscriptionRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ecsrelay {

// ===================================================================

class Identity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecsrelay.Identity) */ {
 public:
  inline Identity() : Identity(nullptr) {}
  ~Identity() override;
  explicit constexpr Identity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Identity(const Identity& from);
  Identity(Identity&& from) noexcept
    : Identity() {
    *this = ::std::move(from);
  }

  inline Identity& operator=(const Identity& from) {
    CopyFrom(from);
    return *this;
  }
  inline Identity& operator=(Identity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Identity& default_instance() {
    return *internal_default_instance();
  }
  static inline const Identity* internal_default_instance() {
    return reinterpret_cast<const Identity*>(
               &_Identity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Identity& a, Identity& b) {
    a.Swap(&b);
  }
  inline void Swap(Identity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Identity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Identity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Identity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Identity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Identity& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Identity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecsrelay.Identity";
  }
  protected:
  explicit Identity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:ecsrelay.Identity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecs_5frelay_2eproto;
};
// -------------------------------------------------------------------

class Signature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecsrelay.Signature) */ {
 public:
  inline Signature() : Signature(nullptr) {}
  ~Signature() override;
  explicit constexpr Signature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Signature(const Signature& from);
  Signature(Signature&& from) noexcept
    : Signature() {
    *this = ::std::move(from);
  }

  inline Signature& operator=(const Signature& from) {
    CopyFrom(from);
    return *this;
  }
  inline Signature& operator=(Signature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Signature& default_instance() {
    return *internal_default_instance();
  }
  static inline const Signature* internal_default_instance() {
    return reinterpret_cast<const Signature*>(
               &_Signature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Signature& a, Signature& b) {
    a.Swap(&b);
  }
  inline void Swap(Signature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Signature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Signature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Signature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Signature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Signature& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecsrelay.Signature";
  }
  protected:
  explicit Signature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 1,
  };
  // string signature = 1;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // @@protoc_insertion_point(class_scope:ecsrelay.Signature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecs_5frelay_2eproto;
};
// -------------------------------------------------------------------

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecsrelay.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit constexpr Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Message& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecsrelay.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kDataFieldNumber = 3,
    kSignatureFieldNumber = 5,
    kTimestampFieldNumber = 4,
    kVersionFieldNumber = 1,
  };
  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string signature = 5;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // int64 timestamp = 4;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // uint32 version = 1;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ecsrelay.Message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  int64_t timestamp_;
  uint32_t version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecs_5frelay_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecsrelay.SubscriptionRequest) */ {
 public:
  inline SubscriptionRequest() : SubscriptionRequest(nullptr) {}
  ~SubscriptionRequest() override;
  explicit constexpr SubscriptionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionRequest(const SubscriptionRequest& from);
  SubscriptionRequest(SubscriptionRequest&& from) noexcept
    : SubscriptionRequest() {
    *this = ::std::move(from);
  }

  inline SubscriptionRequest& operator=(const SubscriptionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionRequest& operator=(SubscriptionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionRequest* internal_default_instance() {
    return reinterpret_cast<const SubscriptionRequest*>(
               &_SubscriptionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SubscriptionRequest& a, SubscriptionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscriptionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecsrelay.SubscriptionRequest";
  }
  protected:
  explicit SubscriptionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 1,
    kSubscriptionFieldNumber = 2,
  };
  // .ecsrelay.Signature signature = 1;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const ::ecsrelay::Signature& signature() const;
  PROTOBUF_NODISCARD ::ecsrelay::Signature* release_signature();
  ::ecsrelay::Signature* mutable_signature();
  void set_allocated_signature(::ecsrelay::Signature* signature);
  private:
  const ::ecsrelay::Signature& _internal_signature() const;
  ::ecsrelay::Signature* _internal_mutable_signature();
  public:
  void unsafe_arena_set_allocated_signature(
      ::ecsrelay::Signature* signature);
  ::ecsrelay::Signature* unsafe_arena_release_signature();

  // .ecsrelay.Subscription subscription = 2;
  bool has_subscription() const;
  private:
  bool _internal_has_subscription() const;
  public:
  void clear_subscription();
  const ::ecsrelay::Subscription& subscription() const;
  PROTOBUF_NODISCARD ::ecsrelay::Subscription* release_subscription();
  ::ecsrelay::Subscription* mutable_subscription();
  void set_allocated_subscription(::ecsrelay::Subscription* subscription);
  private:
  const ::ecsrelay::Subscription& _internal_subscription() const;
  ::ecsrelay::Subscription* _internal_mutable_subscription();
  public:
  void unsafe_arena_set_allocated_subscription(
      ::ecsrelay::Subscription* subscription);
  ::ecsrelay::Subscription* unsafe_arena_release_subscription();

  // @@protoc_insertion_point(class_scope:ecsrelay.SubscriptionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ecsrelay::Signature* signature_;
  ::ecsrelay::Subscription* subscription_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecs_5frelay_2eproto;
};
// -------------------------------------------------------------------

class Subscription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecsrelay.Subscription) */ {
 public:
  inline Subscription() : Subscription(nullptr) {}
  ~Subscription() override;
  explicit constexpr Subscription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Subscription(const Subscription& from);
  Subscription(Subscription&& from) noexcept
    : Subscription() {
    *this = ::std::move(from);
  }

  inline Subscription& operator=(const Subscription& from) {
    CopyFrom(from);
    return *this;
  }
  inline Subscription& operator=(Subscription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Subscription& default_instance() {
    return *internal_default_instance();
  }
  static inline const Subscription* internal_default_instance() {
    return reinterpret_cast<const Subscription*>(
               &_Subscription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Subscription& a, Subscription& b) {
    a.Swap(&b);
  }
  inline void Swap(Subscription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Subscription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Subscription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Subscription>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Subscription& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Subscription& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Subscription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecsrelay.Subscription";
  }
  protected:
  explicit Subscription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelFieldNumber = 1,
  };
  // string label = 1;
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // @@protoc_insertion_point(class_scope:ecsrelay.Subscription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecs_5frelay_2eproto;
};
// -------------------------------------------------------------------

class PushRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecsrelay.PushRequest) */ {
 public:
  inline PushRequest() : PushRequest(nullptr) {}
  ~PushRequest() override;
  explicit constexpr PushRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushRequest(const PushRequest& from);
  PushRequest(PushRequest&& from) noexcept
    : PushRequest() {
    *this = ::std::move(from);
  }

  inline PushRequest& operator=(const PushRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushRequest& operator=(PushRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushRequest* internal_default_instance() {
    return reinterpret_cast<const PushRequest*>(
               &_PushRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PushRequest& a, PushRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PushRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PushRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PushRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecsrelay.PushRequest";
  }
  protected:
  explicit PushRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string label = 1;
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // .ecsrelay.Message message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::ecsrelay::Message& message() const;
  PROTOBUF_NODISCARD ::ecsrelay::Message* release_message();
  ::ecsrelay::Message* mutable_message();
  void set_allocated_message(::ecsrelay::Message* message);
  private:
  const ::ecsrelay::Message& _internal_message() const;
  ::ecsrelay::Message* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::ecsrelay::Message* message);
  ::ecsrelay::Message* unsafe_arena_release_message();

  // @@protoc_insertion_point(class_scope:ecsrelay.PushRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  ::ecsrelay::Message* message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecs_5frelay_2eproto;
};
// -------------------------------------------------------------------

class PushManyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecsrelay.PushManyRequest) */ {
 public:
  inline PushManyRequest() : PushManyRequest(nullptr) {}
  ~PushManyRequest() override;
  explicit constexpr PushManyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushManyRequest(const PushManyRequest& from);
  PushManyRequest(PushManyRequest&& from) noexcept
    : PushManyRequest() {
    *this = ::std::move(from);
  }

  inline PushManyRequest& operator=(const PushManyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushManyRequest& operator=(PushManyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushManyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushManyRequest* internal_default_instance() {
    return reinterpret_cast<const PushManyRequest*>(
               &_PushManyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PushManyRequest& a, PushManyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PushManyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushManyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushManyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushManyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PushManyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PushManyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushManyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecsrelay.PushManyRequest";
  }
  protected:
  explicit PushManyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 3,
    kLabelFieldNumber = 2,
    kSignatureFieldNumber = 1,
  };
  // repeated .ecsrelay.Message messages = 3;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::ecsrelay::Message* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ecsrelay::Message >*
      mutable_messages();
  private:
  const ::ecsrelay::Message& _internal_messages(int index) const;
  ::ecsrelay::Message* _internal_add_messages();
  public:
  const ::ecsrelay::Message& messages(int index) const;
  ::ecsrelay::Message* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ecsrelay::Message >&
      messages() const;

  // string label = 2;
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // .ecsrelay.Signature signature = 1;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const ::ecsrelay::Signature& signature() const;
  PROTOBUF_NODISCARD ::ecsrelay::Signature* release_signature();
  ::ecsrelay::Signature* mutable_signature();
  void set_allocated_signature(::ecsrelay::Signature* signature);
  private:
  const ::ecsrelay::Signature& _internal_signature() const;
  ::ecsrelay::Signature* _internal_mutable_signature();
  public:
  void unsafe_arena_set_allocated_signature(
      ::ecsrelay::Signature* signature);
  ::ecsrelay::Signature* unsafe_arena_release_signature();

  // @@protoc_insertion_point(class_scope:ecsrelay.PushManyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ecsrelay::Message > messages_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  ::ecsrelay::Signature* signature_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecs_5frelay_2eproto;
};
// -------------------------------------------------------------------

class PushResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ecsrelay.PushResponse) */ {
 public:
  inline PushResponse() : PushResponse(nullptr) {}
  explicit constexpr PushResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushResponse(const PushResponse& from);
  PushResponse(PushResponse&& from) noexcept
    : PushResponse() {
    *this = ::std::move(from);
  }

  inline PushResponse& operator=(const PushResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushResponse& operator=(PushResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushResponse* internal_default_instance() {
    return reinterpret_cast<const PushResponse*>(
               &_PushResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PushResponse& a, PushResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PushResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PushResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PushResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecsrelay.PushResponse";
  }
  protected:
  explicit PushResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ecsrelay.PushResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecs_5frelay_2eproto;
};
// -------------------------------------------------------------------

class CountIdentitiesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ecsrelay.CountIdentitiesRequest) */ {
 public:
  inline CountIdentitiesRequest() : CountIdentitiesRequest(nullptr) {}
  explicit constexpr CountIdentitiesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CountIdentitiesRequest(const CountIdentitiesRequest& from);
  CountIdentitiesRequest(CountIdentitiesRequest&& from) noexcept
    : CountIdentitiesRequest() {
    *this = ::std::move(from);
  }

  inline CountIdentitiesRequest& operator=(const CountIdentitiesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CountIdentitiesRequest& operator=(CountIdentitiesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CountIdentitiesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CountIdentitiesRequest* internal_default_instance() {
    return reinterpret_cast<const CountIdentitiesRequest*>(
               &_CountIdentitiesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CountIdentitiesRequest& a, CountIdentitiesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CountIdentitiesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CountIdentitiesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CountIdentitiesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CountIdentitiesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CountIdentitiesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CountIdentitiesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecsrelay.CountIdentitiesRequest";
  }
  protected:
  explicit CountIdentitiesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ecsrelay.CountIdentitiesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecs_5frelay_2eproto;
};
// -------------------------------------------------------------------

class CountIdentitiesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecsrelay.CountIdentitiesResponse) */ {
 public:
  inline CountIdentitiesResponse() : CountIdentitiesResponse(nullptr) {}
  ~CountIdentitiesResponse() override;
  explicit constexpr CountIdentitiesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CountIdentitiesResponse(const CountIdentitiesResponse& from);
  CountIdentitiesResponse(CountIdentitiesResponse&& from) noexcept
    : CountIdentitiesResponse() {
    *this = ::std::move(from);
  }

  inline CountIdentitiesResponse& operator=(const CountIdentitiesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CountIdentitiesResponse& operator=(CountIdentitiesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CountIdentitiesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CountIdentitiesResponse* internal_default_instance() {
    return reinterpret_cast<const CountIdentitiesResponse*>(
               &_CountIdentitiesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CountIdentitiesResponse& a, CountIdentitiesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CountIdentitiesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CountIdentitiesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CountIdentitiesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CountIdentitiesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CountIdentitiesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CountIdentitiesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CountIdentitiesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecsrelay.CountIdentitiesResponse";
  }
  protected:
  explicit CountIdentitiesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountFieldNumber = 1,
  };
  // uint32 count = 1;
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ecsrelay.CountIdentitiesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecs_5frelay_2eproto;
};
// -------------------------------------------------------------------

class BalanceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ecsrelay.BalanceRequest) */ {
 public:
  inline BalanceRequest() : BalanceRequest(nullptr) {}
  explicit constexpr BalanceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BalanceRequest(const BalanceRequest& from);
  BalanceRequest(BalanceRequest&& from) noexcept
    : BalanceRequest() {
    *this = ::std::move(from);
  }

  inline BalanceRequest& operator=(const BalanceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BalanceRequest& operator=(BalanceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BalanceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BalanceRequest* internal_default_instance() {
    return reinterpret_cast<const BalanceRequest*>(
               &_BalanceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BalanceRequest& a, BalanceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BalanceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BalanceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BalanceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BalanceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const BalanceRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const BalanceRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecsrelay.BalanceRequest";
  }
  protected:
  explicit BalanceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ecsrelay.BalanceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecs_5frelay_2eproto;
};
// -------------------------------------------------------------------

class BalanceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecsrelay.BalanceResponse) */ {
 public:
  inline BalanceResponse() : BalanceResponse(nullptr) {}
  ~BalanceResponse() override;
  explicit constexpr BalanceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BalanceResponse(const BalanceResponse& from);
  BalanceResponse(BalanceResponse&& from) noexcept
    : BalanceResponse() {
    *this = ::std::move(from);
  }

  inline BalanceResponse& operator=(const BalanceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BalanceResponse& operator=(BalanceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BalanceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BalanceResponse* internal_default_instance() {
    return reinterpret_cast<const BalanceResponse*>(
               &_BalanceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BalanceResponse& a, BalanceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BalanceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BalanceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BalanceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BalanceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BalanceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BalanceResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BalanceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecsrelay.BalanceResponse";
  }
  protected:
  explicit BalanceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeiFieldNumber = 1,
    kEtherFieldNumber = 2,
  };
  // uint64 wei = 1;
  void clear_wei();
  uint64_t wei() const;
  void set_wei(uint64_t value);
  private:
  uint64_t _internal_wei() const;
  void _internal_set_wei(uint64_t value);
  public:

  // double ether = 2;
  void clear_ether();
  double ether() const;
  void set_ether(double value);
  private:
  double _internal_ether() const;
  void _internal_set_ether(double value);
  public:

  // @@protoc_insertion_point(class_scope:ecsrelay.BalanceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t wei_;
  double ether_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecs_5frelay_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Identity

// string name = 1;
inline void Identity::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Identity::name() const {
  // @@protoc_insertion_point(field_get:ecsrelay.Identity.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Identity::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ecsrelay.Identity.name)
}
inline std::string* Identity::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ecsrelay.Identity.name)
  return _s;
}
inline const std::string& Identity::_internal_name() const {
  return name_.Get();
}
inline void Identity::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Identity::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Identity::release_name() {
  // @@protoc_insertion_point(field_release:ecsrelay.Identity.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Identity::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ecsrelay.Identity.name)
}

// -------------------------------------------------------------------

// Signature

// string signature = 1;
inline void Signature::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& Signature::signature() const {
  // @@protoc_insertion_point(field_get:ecsrelay.Signature.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Signature::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ecsrelay.Signature.signature)
}
inline std::string* Signature::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:ecsrelay.Signature.signature)
  return _s;
}
inline const std::string& Signature::_internal_signature() const {
  return signature_.Get();
}
inline void Signature::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Signature::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Signature::release_signature() {
  // @@protoc_insertion_point(field_release:ecsrelay.Signature.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Signature::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ecsrelay.Signature.signature)
}

// -------------------------------------------------------------------

// Message

// uint32 version = 1;
inline void Message::clear_version() {
  version_ = 0u;
}
inline uint32_t Message::_internal_version() const {
  return version_;
}
inline uint32_t Message::version() const {
  // @@protoc_insertion_point(field_get:ecsrelay.Message.version)
  return _internal_version();
}
inline void Message::_internal_set_version(uint32_t value) {
  
  version_ = value;
}
inline void Message::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:ecsrelay.Message.version)
}

// string id = 2;
inline void Message::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Message::id() const {
  // @@protoc_insertion_point(field_get:ecsrelay.Message.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ecsrelay.Message.id)
}
inline std::string* Message::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ecsrelay.Message.id)
  return _s;
}
inline const std::string& Message::_internal_id() const {
  return id_.Get();
}
inline void Message::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Message::release_id() {
  // @@protoc_insertion_point(field_release:ecsrelay.Message.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Message::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ecsrelay.Message.id)
}

// bytes data = 3;
inline void Message::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& Message::data() const {
  // @@protoc_insertion_point(field_get:ecsrelay.Message.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ecsrelay.Message.data)
}
inline std::string* Message::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:ecsrelay.Message.data)
  return _s;
}
inline const std::string& Message::_internal_data() const {
  return data_.Get();
}
inline void Message::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Message::release_data() {
  // @@protoc_insertion_point(field_release:ecsrelay.Message.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Message::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ecsrelay.Message.data)
}

// int64 timestamp = 4;
inline void Message::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline int64_t Message::_internal_timestamp() const {
  return timestamp_;
}
inline int64_t Message::timestamp() const {
  // @@protoc_insertion_point(field_get:ecsrelay.Message.timestamp)
  return _internal_timestamp();
}
inline void Message::_internal_set_timestamp(int64_t value) {
  
  timestamp_ = value;
}
inline void Message::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:ecsrelay.Message.timestamp)
}

// string signature = 5;
inline void Message::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& Message::signature() const {
  // @@protoc_insertion_point(field_get:ecsrelay.Message.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ecsrelay.Message.signature)
}
inline std::string* Message::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:ecsrelay.Message.signature)
  return _s;
}
inline const std::string& Message::_internal_signature() const {
  return signature_.Get();
}
inline void Message::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Message::release_signature() {
  // @@protoc_insertion_point(field_release:ecsrelay.Message.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Message::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ecsrelay.Message.signature)
}

// -------------------------------------------------------------------

// SubscriptionRequest

// .ecsrelay.Signature signature = 1;
inline bool SubscriptionRequest::_internal_has_signature() const {
  return this != internal_default_instance() && signature_ != nullptr;
}
inline bool SubscriptionRequest::has_signature() const {
  return _internal_has_signature();
}
inline void SubscriptionRequest::clear_signature() {
  if (GetArenaForAllocation() == nullptr && signature_ != nullptr) {
    delete signature_;
  }
  signature_ = nullptr;
}
inline const ::ecsrelay::Signature& SubscriptionRequest::_internal_signature() const {
  const ::ecsrelay::Signature* p = signature_;
  return p != nullptr ? *p : reinterpret_cast<const ::ecsrelay::Signature&>(
      ::ecsrelay::_Signature_default_instance_);
}
inline const ::ecsrelay::Signature& SubscriptionRequest::signature() const {
  // @@protoc_insertion_point(field_get:ecsrelay.SubscriptionRequest.signature)
  return _internal_signature();
}
inline void SubscriptionRequest::unsafe_arena_set_allocated_signature(
    ::ecsrelay::Signature* signature) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signature_);
  }
  signature_ = signature;
  if (signature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ecsrelay.SubscriptionRequest.signature)
}
inline ::ecsrelay::Signature* SubscriptionRequest::release_signature() {
  
  ::ecsrelay::Signature* temp = signature_;
  signature_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ecsrelay::Signature* SubscriptionRequest::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_release:ecsrelay.SubscriptionRequest.signature)
  
  ::ecsrelay::Signature* temp = signature_;
  signature_ = nullptr;
  return temp;
}
inline ::ecsrelay::Signature* SubscriptionRequest::_internal_mutable_signature() {
  
  if (signature_ == nullptr) {
    auto* p = CreateMaybeMessage<::ecsrelay::Signature>(GetArenaForAllocation());
    signature_ = p;
  }
  return signature_;
}
inline ::ecsrelay::Signature* SubscriptionRequest::mutable_signature() {
  ::ecsrelay::Signature* _msg = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:ecsrelay.SubscriptionRequest.signature)
  return _msg;
}
inline void SubscriptionRequest::set_allocated_signature(::ecsrelay::Signature* signature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete signature_;
  }
  if (signature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ecsrelay::Signature>::GetOwningArena(signature);
    if (message_arena != submessage_arena) {
      signature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signature, submessage_arena);
    }
    
  } else {
    
  }
  signature_ = signature;
  // @@protoc_insertion_point(field_set_allocated:ecsrelay.SubscriptionRequest.signature)
}

// .ecsrelay.Subscription subscription = 2;
inline bool SubscriptionRequest::_internal_has_subscription() const {
  return this != internal_default_instance() && subscription_ != nullptr;
}
inline bool SubscriptionRequest::has_subscription() const {
  return _internal_has_subscription();
}
inline void SubscriptionRequest::clear_subscription() {
  if (GetArenaForAllocation() == nullptr && subscription_ != nullptr) {
    delete subscription_;
  }
  subscription_ = nullptr;
}
inline const ::ecsrelay::Subscription& SubscriptionRequest::_internal_subscription() const {
  const ::ecsrelay::Subscription* p = subscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::ecsrelay::Subscription&>(
      ::ecsrelay::_Subscription_default_instance_);
}
inline const ::ecsrelay::Subscription& SubscriptionRequest::subscription() const {
  // @@protoc_insertion_point(field_get:ecsrelay.SubscriptionRequest.subscription)
  return _internal_subscription();
}
inline void SubscriptionRequest::unsafe_arena_set_allocated_subscription(
    ::ecsrelay::Subscription* subscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subscription_);
  }
  subscription_ = subscription;
  if (subscription) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ecsrelay.SubscriptionRequest.subscription)
}
inline ::ecsrelay::Subscription* SubscriptionRequest::release_subscription() {
  
  ::ecsrelay::Subscription* temp = subscription_;
  subscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ecsrelay::Subscription* SubscriptionRequest::unsafe_arena_release_subscription() {
  // @@protoc_insertion_point(field_release:ecsrelay.SubscriptionRequest.subscription)
  
  ::ecsrelay::Subscription* temp = subscription_;
  subscription_ = nullptr;
  return temp;
}
inline ::ecsrelay::Subscription* SubscriptionRequest::_internal_mutable_subscription() {
  
  if (subscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::ecsrelay::Subscription>(GetArenaForAllocation());
    subscription_ = p;
  }
  return subscription_;
}
inline ::ecsrelay::Subscription* SubscriptionRequest::mutable_subscription() {
  ::ecsrelay::Subscription* _msg = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:ecsrelay.SubscriptionRequest.subscription)
  return _msg;
}
inline void SubscriptionRequest::set_allocated_subscription(::ecsrelay::Subscription* subscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete subscription_;
  }
  if (subscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ecsrelay::Subscription>::GetOwningArena(subscription);
    if (message_arena != submessage_arena) {
      subscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscription, submessage_arena);
    }
    
  } else {
    
  }
  subscription_ = subscription;
  // @@protoc_insertion_point(field_set_allocated:ecsrelay.SubscriptionRequest.subscription)
}

// -------------------------------------------------------------------

// Subscription

// string label = 1;
inline void Subscription::clear_label() {
  label_.ClearToEmpty();
}
inline const std::string& Subscription::label() const {
  // @@protoc_insertion_point(field_get:ecsrelay.Subscription.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Subscription::set_label(ArgT0&& arg0, ArgT... args) {
 
 label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ecsrelay.Subscription.label)
}
inline std::string* Subscription::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:ecsrelay.Subscription.label)
  return _s;
}
inline const std::string& Subscription::_internal_label() const {
  return label_.Get();
}
inline void Subscription::_internal_set_label(const std::string& value) {
  
  label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Subscription::_internal_mutable_label() {
  
  return label_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Subscription::release_label() {
  // @@protoc_insertion_point(field_release:ecsrelay.Subscription.label)
  return label_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Subscription::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  label_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), label,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    label_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ecsrelay.Subscription.label)
}

// -------------------------------------------------------------------

// PushRequest

// string label = 1;
inline void PushRequest::clear_label() {
  label_.ClearToEmpty();
}
inline const std::string& PushRequest::label() const {
  // @@protoc_insertion_point(field_get:ecsrelay.PushRequest.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PushRequest::set_label(ArgT0&& arg0, ArgT... args) {
 
 label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ecsrelay.PushRequest.label)
}
inline std::string* PushRequest::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:ecsrelay.PushRequest.label)
  return _s;
}
inline const std::string& PushRequest::_internal_label() const {
  return label_.Get();
}
inline void PushRequest::_internal_set_label(const std::string& value) {
  
  label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PushRequest::_internal_mutable_label() {
  
  return label_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PushRequest::release_label() {
  // @@protoc_insertion_point(field_release:ecsrelay.PushRequest.label)
  return label_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PushRequest::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  label_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), label,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    label_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ecsrelay.PushRequest.label)
}

// .ecsrelay.Message message = 2;
inline bool PushRequest::_internal_has_message() const {
  return this != internal_default_instance() && message_ != nullptr;
}
inline bool PushRequest::has_message() const {
  return _internal_has_message();
}
inline void PushRequest::clear_message() {
  if (GetArenaForAllocation() == nullptr && message_ != nullptr) {
    delete message_;
  }
  message_ = nullptr;
}
inline const ::ecsrelay::Message& PushRequest::_internal_message() const {
  const ::ecsrelay::Message* p = message_;
  return p != nullptr ? *p : reinterpret_cast<const ::ecsrelay::Message&>(
      ::ecsrelay::_Message_default_instance_);
}
inline const ::ecsrelay::Message& PushRequest::message() const {
  // @@protoc_insertion_point(field_get:ecsrelay.PushRequest.message)
  return _internal_message();
}
inline void PushRequest::unsafe_arena_set_allocated_message(
    ::ecsrelay::Message* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_);
  }
  message_ = message;
  if (message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ecsrelay.PushRequest.message)
}
inline ::ecsrelay::Message* PushRequest::release_message() {
  
  ::ecsrelay::Message* temp = message_;
  message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ecsrelay::Message* PushRequest::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:ecsrelay.PushRequest.message)
  
  ::ecsrelay::Message* temp = message_;
  message_ = nullptr;
  return temp;
}
inline ::ecsrelay::Message* PushRequest::_internal_mutable_message() {
  
  if (message_ == nullptr) {
    auto* p = CreateMaybeMessage<::ecsrelay::Message>(GetArenaForAllocation());
    message_ = p;
  }
  return message_;
}
inline ::ecsrelay::Message* PushRequest::mutable_message() {
  ::ecsrelay::Message* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:ecsrelay.PushRequest.message)
  return _msg;
}
inline void PushRequest::set_allocated_message(::ecsrelay::Message* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ecsrelay::Message>::GetOwningArena(message);
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  message_ = message;
  // @@protoc_insertion_point(field_set_allocated:ecsrelay.PushRequest.message)
}

// -------------------------------------------------------------------

// PushManyRequest

// .ecsrelay.Signature signature = 1;
inline bool PushManyRequest::_internal_has_signature() const {
  return this != internal_default_instance() && signature_ != nullptr;
}
inline bool PushManyRequest::has_signature() const {
  return _internal_has_signature();
}
inline void PushManyRequest::clear_signature() {
  if (GetArenaForAllocation() == nullptr && signature_ != nullptr) {
    delete signature_;
  }
  signature_ = nullptr;
}
inline const ::ecsrelay::Signature& PushManyRequest::_internal_signature() const {
  const ::ecsrelay::Signature* p = signature_;
  return p != nullptr ? *p : reinterpret_cast<const ::ecsrelay::Signature&>(
      ::ecsrelay::_Signature_default_instance_);
}
inline const ::ecsrelay::Signature& PushManyRequest::signature() const {
  // @@protoc_insertion_point(field_get:ecsrelay.PushManyRequest.signature)
  return _internal_signature();
}
inline void PushManyRequest::unsafe_arena_set_allocated_signature(
    ::ecsrelay::Signature* signature) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signature_);
  }
  signature_ = signature;
  if (signature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ecsrelay.PushManyRequest.signature)
}
inline ::ecsrelay::Signature* PushManyRequest::release_signature() {
  
  ::ecsrelay::Signature* temp = signature_;
  signature_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ecsrelay::Signature* PushManyRequest::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_release:ecsrelay.PushManyRequest.signature)
  
  ::ecsrelay::Signature* temp = signature_;
  signature_ = nullptr;
  return temp;
}
inline ::ecsrelay::Signature* PushManyRequest::_internal_mutable_signature() {
  
  if (signature_ == nullptr) {
    auto* p = CreateMaybeMessage<::ecsrelay::Signature>(GetArenaForAllocation());
    signature_ = p;
  }
  return signature_;
}
inline ::ecsrelay::Signature* PushManyRequest::mutable_signature() {
  ::ecsrelay::Signature* _msg = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:ecsrelay.PushManyRequest.signature)
  return _msg;
}
inline void PushManyRequest::set_allocated_signature(::ecsrelay::Signature* signature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete signature_;
  }
  if (signature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ecsrelay::Signature>::GetOwningArena(signature);
    if (message_arena != submessage_arena) {
      signature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signature, submessage_arena);
    }
    
  } else {
    
  }
  signature_ = signature;
  // @@protoc_insertion_point(field_set_allocated:ecsrelay.PushManyRequest.signature)
}

// string label = 2;
inline void PushManyRequest::clear_label() {
  label_.ClearToEmpty();
}
inline const std::string& PushManyRequest::label() const {
  // @@protoc_insertion_point(field_get:ecsrelay.PushManyRequest.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PushManyRequest::set_label(ArgT0&& arg0, ArgT... args) {
 
 label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ecsrelay.PushManyRequest.label)
}
inline std::string* PushManyRequest::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:ecsrelay.PushManyRequest.label)
  return _s;
}
inline const std::string& PushManyRequest::_internal_label() const {
  return label_.Get();
}
inline void PushManyRequest::_internal_set_label(const std::string& value) {
  
  label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PushManyRequest::_internal_mutable_label() {
  
  return label_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PushManyRequest::release_label() {
  // @@protoc_insertion_point(field_release:ecsrelay.PushManyRequest.label)
  return label_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PushManyRequest::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  label_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), label,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    label_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ecsrelay.PushManyRequest.label)
}

// repeated .ecsrelay.Message messages = 3;
inline int PushManyRequest::_internal_messages_size() const {
  return messages_.size();
}
inline int PushManyRequest::messages_size() const {
  return _internal_messages_size();
}
inline void PushManyRequest::clear_messages() {
  messages_.Clear();
}
inline ::ecsrelay::Message* PushManyRequest::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:ecsrelay.PushManyRequest.messages)
  return messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ecsrelay::Message >*
PushManyRequest::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:ecsrelay.PushManyRequest.messages)
  return &messages_;
}
inline const ::ecsrelay::Message& PushManyRequest::_internal_messages(int index) const {
  return messages_.Get(index);
}
inline const ::ecsrelay::Message& PushManyRequest::messages(int index) const {
  // @@protoc_insertion_point(field_get:ecsrelay.PushManyRequest.messages)
  return _internal_messages(index);
}
inline ::ecsrelay::Message* PushManyRequest::_internal_add_messages() {
  return messages_.Add();
}
inline ::ecsrelay::Message* PushManyRequest::add_messages() {
  ::ecsrelay::Message* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:ecsrelay.PushManyRequest.messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ecsrelay::Message >&
PushManyRequest::messages() const {
  // @@protoc_insertion_point(field_list:ecsrelay.PushManyRequest.messages)
  return messages_;
}

// -------------------------------------------------------------------

// PushResponse

// -------------------------------------------------------------------

// CountIdentitiesRequest

// -------------------------------------------------------------------

// CountIdentitiesResponse

// uint32 count = 1;
inline void CountIdentitiesResponse::clear_count() {
  count_ = 0u;
}
inline uint32_t CountIdentitiesResponse::_internal_count() const {
  return count_;
}
inline uint32_t CountIdentitiesResponse::count() const {
  // @@protoc_insertion_point(field_get:ecsrelay.CountIdentitiesResponse.count)
  return _internal_count();
}
inline void CountIdentitiesResponse::_internal_set_count(uint32_t value) {
  
  count_ = value;
}
inline void CountIdentitiesResponse::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:ecsrelay.CountIdentitiesResponse.count)
}

// -------------------------------------------------------------------

// BalanceRequest

// -------------------------------------------------------------------

// BalanceResponse

// uint64 wei = 1;
inline void BalanceResponse::clear_wei() {
  wei_ = uint64_t{0u};
}
inline uint64_t BalanceResponse::_internal_wei() const {
  return wei_;
}
inline uint64_t BalanceResponse::wei() const {
  // @@protoc_insertion_point(field_get:ecsrelay.BalanceResponse.wei)
  return _internal_wei();
}
inline void BalanceResponse::_internal_set_wei(uint64_t value) {
  
  wei_ = value;
}
inline void BalanceResponse::set_wei(uint64_t value) {
  _internal_set_wei(value);
  // @@protoc_insertion_point(field_set:ecsrelay.BalanceResponse.wei)
}

// double ether = 2;
inline void BalanceResponse::clear_ether() {
  ether_ = 0;
}
inline double BalanceResponse::_internal_ether() const {
  return ether_;
}
inline double BalanceResponse::ether() const {
  // @@protoc_insertion_point(field_get:ecsrelay.BalanceResponse.ether)
  return _internal_ether();
}
inline void BalanceResponse::_internal_set_ether(double value) {
  
  ether_ = value;
}
inline void BalanceResponse::set_ether(double value) {
  _internal_set_ether(value);
  // @@protoc_insertion_point(field_set:ecsrelay.BalanceResponse.ether)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ecsrelay

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ecs_5frelay_2eproto
